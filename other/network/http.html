<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP 高频面试 | Dai&#39;s blog</title>
    <meta name="description" content="学海无涯，永无止尽">
    <link rel="icon" href="/images/photo1.jpg">
  <link rel="manifest" href="/images/photo1.jpg">
  <link rel="apple-touch-icon" href="/images/photo1.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.7a8c588f.css" as="style"><link rel="preload" href="/assets/js/app.f426d84b.js" as="script"><link rel="preload" href="/assets/js/2.45113de2.js" as="script"><link rel="prefetch" href="/assets/js/10.598aec70.js"><link rel="prefetch" href="/assets/js/11.0a334ef2.js"><link rel="prefetch" href="/assets/js/12.f83989bb.js"><link rel="prefetch" href="/assets/js/13.dd91d8f5.js"><link rel="prefetch" href="/assets/js/14.a621ceac.js"><link rel="prefetch" href="/assets/js/15.ad3aee55.js"><link rel="prefetch" href="/assets/js/16.7970749b.js"><link rel="prefetch" href="/assets/js/17.e27753d2.js"><link rel="prefetch" href="/assets/js/18.1fe75540.js"><link rel="prefetch" href="/assets/js/19.0c5bd26b.js"><link rel="prefetch" href="/assets/js/20.ec4acfac.js"><link rel="prefetch" href="/assets/js/21.1e0b9fa7.js"><link rel="prefetch" href="/assets/js/22.0f634031.js"><link rel="prefetch" href="/assets/js/23.c4ff9424.js"><link rel="prefetch" href="/assets/js/24.6febaf73.js"><link rel="prefetch" href="/assets/js/25.49be9a43.js"><link rel="prefetch" href="/assets/js/26.8a9a71ec.js"><link rel="prefetch" href="/assets/js/27.17146263.js"><link rel="prefetch" href="/assets/js/28.e0a2e3c6.js"><link rel="prefetch" href="/assets/js/29.dc94d080.js"><link rel="prefetch" href="/assets/js/3.3d736d2f.js"><link rel="prefetch" href="/assets/js/30.f72dd6e2.js"><link rel="prefetch" href="/assets/js/31.42ec33bb.js"><link rel="prefetch" href="/assets/js/32.e00a4c90.js"><link rel="prefetch" href="/assets/js/33.cf1f4856.js"><link rel="prefetch" href="/assets/js/34.f8c9eb5c.js"><link rel="prefetch" href="/assets/js/35.b629392d.js"><link rel="prefetch" href="/assets/js/36.ae67625f.js"><link rel="prefetch" href="/assets/js/37.34e4a8dd.js"><link rel="prefetch" href="/assets/js/38.aa0e663a.js"><link rel="prefetch" href="/assets/js/39.3764f79c.js"><link rel="prefetch" href="/assets/js/4.1ac1a89c.js"><link rel="prefetch" href="/assets/js/40.6372fb99.js"><link rel="prefetch" href="/assets/js/5.6477920e.js"><link rel="prefetch" href="/assets/js/6.d0ca8e10.js"><link rel="prefetch" href="/assets/js/7.908bb025.js"><link rel="prefetch" href="/assets/js/8.53a275f3.js"><link rel="prefetch" href="/assets/js/9.bffbc9ba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7a8c588f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dai's blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JS/JS-interview/interview.html" class="nav-link">JS核心面试</a></li><li class="dropdown-item"><!----> <a href="/JS/JS-handwriting/handwriting.html" class="nav-link">JS核心手写</a></li><li class="dropdown-item"><!----> <a href="/JS/Promise/promise.html" class="nav-link">Promise面试题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CSS/CSS-interview/interview.html" class="nav-link">CSS核心面试</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-layout/layout.html" class="nav-link">CSS常见布局</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-flex/flex.html" class="nav-link">Flex布局</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue-basic/basic.html" class="nav-link">vue2.0基础</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-advanced/advanced.html" class="nav-link">vue2.0进阶</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-interview/interview.html" class="nav-link">vue核心面试</a></li><li class="dropdown-item"><!----> <a href="/vue/sourceCode/intro/intro.html" class="nav-link">vue源码解析</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/webpack/webpack_basic.html" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/other/typeScript/base.html" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/other/git/git.html" class="nav-link">Git 操作</a></li><li class="dropdown-item"><!----> <a href="/other/network/http.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">计算机网络</a></li></ul></div></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JS/JS-interview/interview.html" class="nav-link">JS核心面试</a></li><li class="dropdown-item"><!----> <a href="/JS/JS-handwriting/handwriting.html" class="nav-link">JS核心手写</a></li><li class="dropdown-item"><!----> <a href="/JS/Promise/promise.html" class="nav-link">Promise面试题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CSS/CSS-interview/interview.html" class="nav-link">CSS核心面试</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-layout/layout.html" class="nav-link">CSS常见布局</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-flex/flex.html" class="nav-link">Flex布局</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue-basic/basic.html" class="nav-link">vue2.0基础</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-advanced/advanced.html" class="nav-link">vue2.0进阶</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-interview/interview.html" class="nav-link">vue核心面试</a></li><li class="dropdown-item"><!----> <a href="/vue/sourceCode/intro/intro.html" class="nav-link">vue源码解析</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/webpack/webpack_basic.html" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/other/typeScript/base.html" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/other/git/git.html" class="nav-link">Git 操作</a></li><li class="dropdown-item"><!----> <a href="/other/network/http.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">计算机网络</a></li></ul></div></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>HTTP 高频面试</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/other/network/http.html#什么是-http" class="sidebar-link">什么是 HTTP ?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#http-的特点和缺点" class="sidebar-link">HTTP 的特点和缺点?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#http-请求报文的组成成分？" class="sidebar-link">HTTP 请求报文的组成成分？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#http-的请求方法？" class="sidebar-link">HTTP 的请求方法？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#get-和-post-的区别" class="sidebar-link">GET 和 POST 的区别?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#常见的-http-状态码？" class="sidebar-link">常见的 HTTP 状态码？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#什么是持久链接-长连接？" class="sidebar-link">什么是持久链接/长连接？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#什么是管线化-管道化" class="sidebar-link">什么是管线化(管道化)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#如何解决-http-的队头阻塞问题" class="sidebar-link">如何解决 HTTP 的队头阻塞问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#http-和-https-区别" class="sidebar-link">HTTP 和 HTTPS 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#http1-和-http2-的区别？" class="sidebar-link">HTTP1 和 HTTP2 的区别？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#多路复用" class="sidebar-link">多路复用</a></li></ul></li><li><a href="/other/network/http.html#浏览器缓存问题？" class="sidebar-link">浏览器缓存问题？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#什么是缓存呢？" class="sidebar-link">什么是缓存呢？</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#缓存有哪些好处？" class="sidebar-link">缓存有哪些好处？</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#web缓存种类" class="sidebar-link">Web缓存种类</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#强缓存" class="sidebar-link">强缓存</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#协商缓存" class="sidebar-link">协商缓存</a></li></ul></li><li><a href="/other/network/http.html#浏览器存储方式有哪些？" class="sidebar-link">浏览器存储方式有哪些？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#为什么会出现-cookie" class="sidebar-link">为什么会出现 cookie?</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#cookie-生存周期" class="sidebar-link">Cookie 生存周期</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#作用域" class="sidebar-link">作用域</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#安全相关" class="sidebar-link">安全相关</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#cookie-的安全问题" class="sidebar-link">Cookie 的安全问题?</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#cookie" class="sidebar-link">Cookie</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#localstorage-sessionstorage" class="sidebar-link">localStorage / sessionStorage</a></li></ul></li><li><a href="/other/network/http.html#了解-accept-相关字段？" class="sidebar-link">了解 Accept 相关字段？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#数据格式" class="sidebar-link">数据格式</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#压缩方式" class="sidebar-link">压缩方式</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#支持语言" class="sidebar-link">支持语言</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#代码字符集" class="sidebar-link">代码字符集</a></li></ul></li><li><a href="/other/network/http.html#说一说三次握手？" class="sidebar-link">说一说三次握手？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#为什么-tcp-连接需要3次握手，而不是两次" class="sidebar-link">为什么 TCP 连接需要3次握手，而不是两次</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#为什么-tcp-连接不是四次握手？" class="sidebar-link">为什么 TCP 连接不是四次握手？</a></li></ul></li><li><a href="/other/network/http.html#说一说四次挥手？" class="sidebar-link">说一说四次挥手？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#为什么是四次挥手而不是三次？" class="sidebar-link">为什么是四次挥手而不是三次？</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#如果是三次挥手会有什么问题？" class="sidebar-link">如果是三次挥手会有什么问题？</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#为何客户端最后还等待-2msl？" class="sidebar-link">为何客户端最后还等待 2MSL？</a></li></ul></li><li><a href="/other/network/http.html#从输入url到页面展示，发生了什么" class="sidebar-link">从输入URL到页面展示，发生了什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#什么是-tcp-和-udp？" class="sidebar-link">什么是 TCP 和 UDP？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#对于定长和不定长的数据，http-是怎么传输的？" class="sidebar-link">对于定长和不定长的数据，HTTP 是怎么传输的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#定长包体" class="sidebar-link">定长包体</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#不定长包体" class="sidebar-link">不定长包体</a></li></ul></li><li><a href="/other/network/http.html#http-如何处理大文件的传输？" class="sidebar-link">HTTP 如何处理大文件的传输？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#如何支持" class="sidebar-link">如何支持</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#range-字段拆解" class="sidebar-link">Range 字段拆解</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#单段数据" class="sidebar-link">单段数据</a></li></ul></li><li><a href="/other/network/http.html#什么是-https？" class="sidebar-link">什么是 HTTPS？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#传统-rsa-加密算法？" class="sidebar-link">传统 RSA 加密算法？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#对称加密和非对称加密" class="sidebar-link">对称加密和非对称加密</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#对称加密和非对称加密的结合" class="sidebar-link">对称加密和非对称加密的结合</a></li><li class="sidebar-sub-header"><a href="/other/network/http.html#添加数字证书" class="sidebar-link">添加数字证书</a></li></ul></li><li><a href="/other/network/http.html#tls1-2-握手的过程？" class="sidebar-link">TLS1.2 握手的过程？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/other/network/http.html#tls-1-2-握手过程" class="sidebar-link">TLS 1.2 握手过程</a></li></ul></li><li><a href="/other/network/http.html#tls1-3-握手的过程？" class="sidebar-link">TLS1.3 握手的过程？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#xss-讲一下？" class="sidebar-link">XSS 讲一下？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/other/network/http.html#csrf-攻击讲一下？" class="sidebar-link">CSRF 攻击讲一下？</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="http-高频面试"><a href="#http-高频面试" class="header-anchor">#</a> HTTP 高频面试</h1> <h2 id="什么是-http"><a href="#什么是-http" class="header-anchor">#</a> 什么是 HTTP ?</h2> <p><code>HTTP</code> 全称<code>超文本传输协议</code>是一种允许浏览器向服务器获取资源的协议，通常由浏览器发起请求，用来获取不同类型的文件，例如 <code>HTML</code> 文件、<code>CSS</code> 文件、<code>JavaScript</code> 文件、图片、视频等。</p> <h2 id="http-的特点和缺点"><a href="#http-的特点和缺点" class="header-anchor">#</a> HTTP 的特点和缺点?</h2> <p><strong>特点：</strong> <code>无连接</code>、<code>无状态</code>、<code>灵活</code>、<code>简单快速</code></p> <ul><li><code>无连接</code>：每次请求结束后都要重新连接一次，不会保持连接 （<code>http 1.0</code>）</li> <li><code>无状态</code>：每一次请求都是独立的，请求结束后不会记录连接的任何信息，减少了网络开销，这是优点也是缺点</li> <li><code>灵活</code>：通过 <code>http</code> 协议中头部的 <code>Content-Type</code> 标记，可以传输任意数据类型的数据对象(<code>文本</code>、<code>图片</code>、<code>视频</code>等等)，非常灵活</li> <li><code>简单快速</code>：当请求某个资源时，只需发送<code>请求方法</code>和 <code>URL</code> 就可以了，使用简单</li></ul> <p><strong>缺点：</strong> <code>无状态</code>、<code>不安全</code>、<code>明文传输</code>、<code>队头阻塞</code></p> <ul><li><code>无状态</code>：用户的两次 <code>http</code> 请求，服务端并不能通过请求本身来知道这两次请求是来自同一个用户</li> <li><code>不安全</code>：是因为 <code>http</code> 是明文传输，且不能进行对其加密，其保存的信息可能被窃取</li> <li><code>明文传输</code>：明文传输会导致其信息会被窃取</li> <li><code>队头阻塞</code>：开启长连接时，只建立一个 <code>TCP</code> 连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能处于阻塞状态</li></ul> <h2 id="http-请求报文的组成成分？"><a href="#http-请求报文的组成成分？" class="header-anchor">#</a> HTTP 请求报文的组成成分？</h2> <p><code>http</code> 报文：由<code>请求报文</code>和<code>响应报文</code>组成</p> <p><code>请求报文</code>和<code>响应报文</code> 分别由<code>起始行</code>、<code>HTTP头部</code>、<code>空行</code>和<code>实体</code>组成</p> <p><code>起始行：</code></p> <ul><li>对于<code>请求报文</code>，起始行分别由<code>请求方法 + 路径 + HTTP协议及版本</code>组成</li> <li>对于<code>响应报文</code>，起始行分别由<code>HTTP协议及版本 + 状态码 + 原因</code>组成</li></ul> <p><code>HTTP头部:</code> 就是一些 <code>key: value</code> 来告诉服务端我要哪些内容，要注意什么类型等</p> <p><code>空行：</code> 用来区分<code>HTTP头部</code>和<code>实体</code></p> <p><code>实体：</code> 如果是<code>请求报文</code>，那就是请求参数，如果是<code>响应报文</code>，那就是服务器返回的数据</p> <p>问: 如果说在头部中间故意加一个空行会怎么样？</p> <p>那么空行后的内容全部被视为实体。</p> <h2 id="http-的请求方法？"><a href="#http-的请求方法？" class="header-anchor">#</a> HTTP 的请求方法？</h2> <p><strong>http1.0：</strong> <code>GET</code>、<code>POST</code>、<code>HEAD</code></p> <p><strong>http1.1：</strong> <code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>CONNECT</code>、<code>OPTIONS</code>、<code>TRACE</code>、</p> <table><thead><tr><th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>GET</td> <td>通常用来获取资源</td></tr> <tr><td>POST</td> <td>提交数据，即上传数据</td></tr> <tr><td>HEAD</td> <td>获取资源的元信息</td></tr> <tr><td>PUT</td> <td>修改数据</td></tr> <tr><td>DELETE</td> <td>删除资源(几乎用不到)</td></tr> <tr><td>CONNECT</td> <td>建立连接隧道，通常用于代理服务器</td></tr> <tr><td>OPTIONS</td> <td>列出可对资源实行的请求方法，通常用来跨域请求</td></tr> <tr><td>TRACE</td> <td>追踪请求-响应的传输路径</td></tr></tbody></table> <h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> GET 和 POST 的区别?</h2> <p>主要有以下几个角度来分析：</p> <ul><li>从语义上的角度，<code>GET</code> 请求通常用来获取资源，而 <code>POST</code> 请求是提交数据，即上传数据。</li> <li>从缓存的角度，<code>GET</code> 请求会被浏览器主动缓存下来，留下历史记录，而 <code>POST</code> 默认不会。</li> <li>从编码的角度，<code>GET</code> 请求只能进行 <code>URL</code> 编码，只能接受 <code>ASCII</code> 字符，而 <code>POST</code> 没有限制。</li> <li>从参数的角度，<code>GET</code> 请求一般放在 <code>URL</code> 中，因此不安全，<code>POST</code> 放在请求体中，更适合传输敏感信息。</li> <li>从幂等性的角度，<code>GET</code> 请求是幂等的，而 <code>POST</code> 不是。(幂等表示执行相同的操作，结果也是相同的)</li> <li>从 <code>TCP</code> 的角度，<code>GET</code> 请求会把请求报文一次性发出去，而 <code>POST</code> 请求会分为两个 <code>TCP</code> 数据包，首先发 <code>header</code> 部分， 如果服务端响应 <code>100</code>，然后发 <code>body</code> 部分。(火狐浏览器除外，它的 <code>POST</code> 请求只发一个 <code>TCP</code> 包)</li></ul> <h2 id="常见的-http-状态码？"><a href="#常见的-http-状态码？" class="header-anchor">#</a> 常见的 HTTP 状态码？</h2> <table><thead><tr><th style="text-align:center">状态码</th> <th style="text-align:left">描述</th></tr></thead> <tbody><tr><td style="text-align:center">1xx（协议的中间状态）</td> <td style="text-align:left"></td></tr> <tr><td style="text-align:center">101</td> <td style="text-align:left">在 <code>HTTP</code> 升级为 <code>WebSocket</code> 的时候，如果服务器同意变更，就会发送状态码 <code>101</code></td></tr> <tr><td style="text-align:center">2xx（请求成功）</td> <td style="text-align:left"></td></tr> <tr><td style="text-align:center">200 ok</td> <td style="text-align:left">表示请求成功，数据正常返回</td></tr> <tr><td style="text-align:center">204</td> <td style="text-align:left">表示请求成功，但是服务端没有内容给你</td></tr> <tr><td style="text-align:center">3xx（重定向）</td> <td style="text-align:left"></td></tr> <tr><td style="text-align:center">301</td> <td style="text-align:left">永久重定向(当访问一个永久重定向的网站的时候,一个域名被指向一个其他网站,且是 永久的)，会缓存</td></tr> <tr><td style="text-align:center">302</td> <td style="text-align:left">临时重定向，不会缓存，但是会在重定向的时候改变 method: 把 POST 请求改成 GET 请求</td></tr> <tr><td style="text-align:center">304</td> <td style="text-align:left">走缓存(服务端觉得你之前请求过这个东西,而且服务器上的那一份没有发生变化,告诉客户端用缓存就行)</td></tr> <tr><td style="text-align:center">307</td> <td style="text-align:left">临时重定向，在重定向时不会改变 method</td></tr> <tr><td style="text-align:center">4xx（客户端错误）</td> <td style="text-align:left"></td></tr> <tr><td style="text-align:center">400</td> <td style="text-align:left">参数传递不当，导致的错误，请求错误</td></tr> <tr><td style="text-align:center">401</td> <td style="text-align:left">权限不够导致的</td></tr> <tr><td style="text-align:center">403</td> <td style="text-align:left">服务端已经理解请求，但是拒绝响应</td></tr> <tr><td style="text-align:center">404</td> <td style="text-align:left">客户端请求的资源或者数据不存在(发现请求接口 404，有两种情况一种是咱们写错接口了或者服务端还没部署)</td></tr> <tr><td style="text-align:center">5xx（服务端错误）</td> <td style="text-align:left"></td></tr> <tr><td style="text-align:center">500</td> <td style="text-align:left">服务端内部错误</td></tr> <tr><td style="text-align:center">502</td> <td style="text-align:left">网关错误</td></tr> <tr><td style="text-align:center">503</td> <td style="text-align:left">服务器繁忙</td></tr></tbody></table> <h2 id="什么是持久链接-长连接？"><a href="#什么是持久链接-长连接？" class="header-anchor">#</a> 什么是持久链接/长连接？</h2> <p><code>http1.0</code> 协议采用的是<code>请求-应答</code>模式，也就是说，每次 <code>HTTP</code> 请求结束后，都必须重新建立一个 <code>TCP</code> 连接</p> <p><code>http1.1</code> 版本支持长连接，即请求头添加 <code>Connection: Keep-Alive</code>，使用 <code>Keep-Alive</code> 模式(又称持久连接，连接复用)建立一个 <code>TCP</code> 连接后使<code>客户端到服务端的连接持续有效</code>，
并且可以发送多个 <code>http</code> 请求，使用 <code>Keep-Alive</code> 模式避免了 <code>TCP</code> 的重新建立连接</p> <p><strong>长连接优缺点</strong></p> <p><strong>优点：</strong></p> <ul><li><code>减少 CPU 及内存的使用</code>，因为不需要经常建立和关闭连接</li> <li><code>支持管道化</code>的请求及响应模式</li> <li><code>减少网络堵塞</code>，因为减少了TCP请求</li> <li><code>减少了后续请求的响应时间</code>，因为不需要等待建立TCP、握手、挥手、关闭TCP的过程</li> <li><code>发生错误时</code>，也可在不关闭连接的情况下进行错误提示</li></ul> <p><strong>缺点：</strong></p> <ul><li>一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，而且长连接时间的长短，直接影响到服务器的并发数</li> <li><code>可能会造成队头堵塞</code></li></ul> <h2 id="什么是管线化-管道化"><a href="#什么是管线化-管道化" class="header-anchor">#</a> 什么是管线化(管道化)</h2> <p>管线化是在同一个 <code>TCP</code> 连接里发一个请求后不必等其回来就可以继续发送请求，这可以减少整体的响应时间，但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题<code>队头堵塞</code></p> <h2 id="如何解决-http-的队头阻塞问题"><a href="#如何解决-http-的队头阻塞问题" class="header-anchor">#</a> 如何解决 HTTP 的队头阻塞问题</h2> <p><code>http1.1</code> 版本支持长连接，也同时支持管道化的连接方式，管线化是在同一个 <code>TCP</code> 连接里发一个请求后不必等其回来就可以继续发送请求，这可以减少整体的响应时间，
但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，其他请求就只能处于阻塞状态，因此就叫<code>队头堵塞</code>。解决如下：</p> <p><strong>并发连接</strong></p> <p>因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。以前在 <code>RFC2616</code> 中规定过客户端最多只能并发 <code>2</code> 个连接，
但是现实是很多浏览器不按套路出牌，就是遵守这个标准 <code>T_T</code>，所以在 <code>RFC7230</code> 把这个规定取消掉了，现在的浏览器标准中一个域名并发连接可以有 <code>6~8</code> 个，记住是 <code>6~8</code> 个，
不是 <code>6</code> 个(<code>Chrome 6</code> 个/ <code>Firefox 8</code> 个)</p> <p><strong>域名分片</strong></p> <p>一个域名最多可以并发 <code>6~8</code> 个，那咱就多来几个域名
比如 <code>a.baidu.com</code>，<code>b.baidu.com</code>，<code>c.baidu.com</code>，多准备几个二级域名，当我们访问 <code>baidu.com</code> 时，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了
而在 <code>HTTP2.0</code> 下，可以一瞬间加载出来很多资源，因为支持多路复用，可以在一个 <code>TCP</code> 连接中发送多个请求</p> <h2 id="http-和-https-区别"><a href="#http-和-https-区别" class="header-anchor">#</a> HTTP 和 HTTPS 区别</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <ol><li><code>HTTP</code> 的 <code>URL</code> 以 <code>http://</code> 开头，而 <code>HTTPS</code> 的 <code>URL</code> 以 <code>https://</code> 开头</li> <li><code>HTTP</code> 是<code>明文传输</code>, 因此是不安全的，而 <code>HTTPS</code> 是<code>加密传输</code>，因此是安全的</li> <li><code>HTTP</code> 标准端口是 <code>80</code> ，而 <code>HTTPS</code> 的标准端口是 <code>443</code></li> <li>在<code>OSI</code> 网络模型中，<code>HTTP</code> 工作于应用层，而 <code>HTTPS</code> 的安全传输机制(<code>TLS</code>)工作在传输层</li> <li><code>HTTP</code> 无法加密，而 <code>HTTPS</code> 对传输的数据进行加密</li> <li><code>HTTP</code>无需证书，而 <code>HTTPS</code> 需要 <code>CA</code> 机构 <code>wosign</code> 的颁发的 <code>SSL</code> 证书</li> <li><code>HTTP</code> 是无状态的，<code>HTTPS</code> 是有状态的</li> <li>连接方式不同，<code>HTTP</code> 三次握手，<code>HTTPS</code> 中 <code>TLS1.2</code> 版本 <code>7</code> 次，<code>TLS1.3</code> 版本 <code>6</code> 次</li></ol></div> <h2 id="http1-和-http2-的区别？"><a href="#http1-和-http2-的区别？" class="header-anchor">#</a> HTTP1 和 HTTP2 的区别？</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <ol><li><code>http2</code> 采用二进制格式而非文本格式。</li> <li><code>http2</code> 是完全多路复用的，而非有序并阻塞的。</li> <li><code>http2</code> 采用了报头压缩，降低了成本。</li> <li><code>http2</code> 让服务器可以主动将响应推送到客户端缓存中</li></ol></div> <h3 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h3> <p>每个 <code>HTTP</code> 请求都有一个序列标识符，这样浏览器可以并发多个请求，服务器接收到数据后，再根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且同一个域名下的所有请求都复用同一个 <code>TCP</code> 连接，极大增加了服务器处理并发的上限。</p> <h4 id="http-队头阻塞"><a href="#http-队头阻塞" class="header-anchor">#</a> HTTP 队头阻塞</h4> <p>而 <code>HTTP/2</code> 便从 <code>HTTP</code> 协议本身解决了队头阻塞问题。注意，这里并不是指的 <code>TCP</code> 队头阻塞，而是 <code>HTTP</code> 队头阻塞，两者并不是一回事。<code>TCP</code> 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 <code>HTTP</code>，而 <code>HTTP</code> 的队头阻塞是在 <code>HTTP</code> 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。</p> <p>那么 <code>HTTP/2</code> 如何来解决所谓的队头阻塞呢？</p> <h4 id="二进制分帧"><a href="#二进制分帧" class="header-anchor">#</a> 二进制分帧</h4> <p><code>HTTP2</code> 采用二进制格式传输，取代了 <code>HTTP1.x</code> 的文本格式，二进制格式解析更高效。</p> <p>原来 <code>Headers + Body</code> 的报文格式如今被拆分成了一个个二进制的帧，用 <code>Headers</code> 帧存放头部字段，<code>Data</code> 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 <code>HTTP</code> 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。</p> <p>多路复用代替了 <code>HTTP1.x</code> 的序列和阻塞机制，所有的相同域名请求都通过同一 个 <code>TCP</code> 连接并发完成。</p> <p>在 <code>HTTP1.x</code> 中，并发多个请求需要多个 <code>TCP</code> 连接，浏览器为了控制资源会有 <code>6-8</code> 个 <code>TCP</code> 连接的限制。<code>HTTP2</code> 中同域名下所有通信都在单个连接上完成，消除了因多个 <code>TCP</code> 连接而带来的延时和内存消耗。</p> <p>单个连接上可以并行交错的请求和响应，之间互不干扰</p> <p>通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(<code>Stream</code>)。<code>HTTP/2</code> 用流来在一个 <code>TCP</code> 连接上来进行多个数据帧的通信，这就是多路复用的概念。
可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p> <p>首先要声明的是，所谓的乱序，指的是不同 <code>ID</code> 的 <code>Stream</code> 是乱序的，但同一个 <code>Stream ID</code> 的帧一定是按顺序传输的。二进制帧到达后对方会将 <code>Stream ID</code> 相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能，我们放到下一节再来介绍。</p> <p><strong>HTTP、HTTPS 以及 HTTP2，如下图所示：</strong></p> <p><img src="/assets/img/9.4d8caebb.png" alt></p> <h2 id="浏览器缓存问题？"><a href="#浏览器缓存问题？" class="header-anchor">#</a> 浏览器缓存问题？</h2> <h3 id="什么是缓存呢？"><a href="#什么是缓存呢？" class="header-anchor">#</a> 什么是缓存呢？</h3> <p>当首次进入一个网站，电脑会把这个网站的一些图片和数据等资源缓存在电脑上，当第二次访问这个网站时，浏览器就会自动帮助我们加载出来，这就是缓存</p> <h3 id="缓存有哪些好处？"><a href="#缓存有哪些好处？" class="header-anchor">#</a> 缓存有哪些好处？</h3> <ul><li><ol><li>缓解服务器压力，不用每次都去请求某些数据了。</li></ol></li> <li><ol start="2"><li>提升性能，打开本地资源肯定会比请求服务器来的快。</li></ol></li> <li><ol start="3"><li>减少带宽消耗，当我们使用缓存时，只会产生很小的网络消耗。</li></ol></li></ul> <h3 id="web缓存种类"><a href="#web缓存种类" class="header-anchor">#</a> Web缓存种类</h3> <p>数据库缓存，CDN缓存，代理服务器缓存，浏览器缓存</p> <p><strong>浏览器缓存过程：</strong> 强缓存，协商缓存。</p> <p><strong>浏览器缓存位置一般分为四类：</strong>  Service Worker--&gt;Memory Cache--&gt;Disk Cache--&gt;Push Cache。</p> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <p>强缓存是当我们访问 <code>URL</code> 的时候，不会向服务器发送请求，直接从缓存中读取数据，并且会返回 <code>200</code> 的状态码</p> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。</p> <p>主要有以下两种情况：</p> <ul><li>协商缓存生效，返回 <code>304</code></li> <li>协商缓存失效，返回 <code>200</code> 和全新的资源</li></ul> <h4 id="如何设置强缓存？"><a href="#如何设置强缓存？" class="header-anchor">#</a> 如何设置强缓存？</h4> <p>第一次请求时，浏览器会根据响应头来判断是否对资源进行缓存，如果响应头中有 <code>expires</code>、<code>pragma</code> 或者 <code>cache-control</code> 字段，代表这是强缓存，
不会向服务器发送请求，浏览器就会把资源缓存在 <code>memory cache</code> 或 <code>disk cache</code> 中。</p> <p>第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接从缓存中读取数据，并且会返回 <code>200</code> 的状态码。否则浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来看是否符合协商缓存，
符合则返回状态码 <code>304</code>，不符合则返回 <code>200</code> 和全新的资源。</p> <img src="/assets/img/1.bca330de.png" width="900"> <p><strong>expires</strong></p> <p>是 <code>HTTP1.0</code> 控制网页缓存的字段，值为一个时间戳，准确来讲是格林尼治时间，服务器返回该请求结果缓存的到期时间，意思是，再次发送请求时，如果未超过过期时间，直接使用该缓存，如果过期了则重新请求。
有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。</p> <p><strong>Cache-Control</strong></p> <p>是 <code>HTTP1.1</code> 中控制网页缓存的字段，当 <code>Cache-Control</code> 都存在时，<code>Cache-Control</code> 优先级更高，主要取值为：</p> <ul><li><code>public：</code>资源客户端和服务器都可以缓存。</li> <li><code>private：</code>资源只有客户端可以缓存。</li> <li><code>no-cache：</code>客户端缓存资源，但是是否缓存需要经过协商缓存来验证。</li> <li><code>no-store：</code>不使用缓存。</li> <li><code>max-age：</code>缓存保质期。</li></ul> <p><strong>pragma</strong></p> <p>这个是 <code>HTTP1.0</code> 中禁用网页缓存的字段，其取值为 <code>no-cache</code>，和 <code>Cache-Control</code> 的 <code>no-cache</code> 效果一样。</p> <img src="/assets/img/2.dcb426c4.png" width="700"> <h4 id="如何设置协商缓存？"><a href="#如何设置协商缓存？" class="header-anchor">#</a> 如何设置协商缓存？</h4> <p><strong>Last-Modified / If-Modified-Since</strong></p> <p><code>Last-Modified</code> 是服务器响应请求时，返回该资源在服务器最后被修改的时间。</p> <p><code>If-Modified-Since</code> 则是客户端再次发起该请求时，携带上次请求返回的 <code>Last-Modified</code> 值，服务器收到该请求，会根据 <code>If-Modified-Since</code> 的字段值与该资源在服务器的最后被修改时间做对比，
若服务器的资源最后被修改时间大于 <code>If-Modified-Since</code> 的字段值，则返回全新的资源，状态码为 <code>200</code>；否则则返回 <code>304</code>，代表资源无更新，可继续使用缓存文件。</p> <p><strong>Etag / If-None-Match</strong></p> <p><code>Etag</code> 是服务器响应请求时，返回当前资源文件的唯一标识(由服务器生成)。</p> <p><code>If-None-Match</code> 是客户端再次发起该请求时，携带上次请求返回的唯一标识 <code>Etag</code> 值，会根据 <code>If-None-Match</code> 的字段值与该资源在服务器的 <code>Etag</code> 值做对比，
一致则返回 <code>304</code>，代表资源无更新，继续使用缓存；不一致则返回全新的资源，状态码为 <code>200</code>。</p> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p><code>Etag / If-None-Match</code> 优先级高于 <code>Last-Modified / If-Modified-Since</code>，同时存在则只有 <code>Etag / If-None-Match</code> 生效。</p></div> <p><strong>Etag如何生成</strong></p> <p><code>nginx</code> 中 <code>etag</code> 由响应头的 <code>Last-Modified</code> 与 <code>Content-Length</code> 表示为十六进制组合而成</p> <h2 id="浏览器存储方式有哪些？"><a href="#浏览器存储方式有哪些？" class="header-anchor">#</a> 浏览器存储方式有哪些？</h2> <p>浏览器存储方式主要有 <code>cookie</code>、<code>localStorage</code>、<code>sessionStorage</code>。</p> <h3 id="为什么会出现-cookie"><a href="#为什么会出现-cookie" class="header-anchor">#</a> 为什么会出现 cookie?</h3> <p><code>Cookie</code> 它的出现是为了解决 <code>HTTP</code> 协议无状态特性的问题 简单理解就是：用户的两次 <code>HTTP</code> 请求，服务端并不能通过请求本身来知道这两次请求是来自于同一个用户</p> <h3 id="cookie-生存周期"><a href="#cookie-生存周期" class="header-anchor">#</a> Cookie 生存周期</h3> <p><code>Cookie</code> 的有效期可以通过 <code>Expires</code> 和 <code>Max-Age</code> 两个属性来设置。</p> <ul><li><code>Expires</code> 即过期时间</li> <li><code>Max-Age</code> 用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li></ul> <p>若 <code>Cookie</code> 过期，则这个 <code>Cookie</code> 会被删除，并不会发送给服务端。</p> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>关于作用域也有两个属性: <code>Domain</code> 和 <code>path</code>, 给 <code>Cookie</code> 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 <code>Cookie</code>。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 <code>Cookie</code>。</p> <h3 id="安全相关"><a href="#安全相关" class="header-anchor">#</a> 安全相关</h3> <p>如果带上 <code>Secure</code>，说明只能通过 <code>HTTPS</code> 传输 <code>cookie。</code></p> <p>如果 <code>cookie</code> 字段带上 <code>HttpOnly</code>，那么说明只能通过 <code>HTTP</code> 协议传输，不能通过 <code>JS</code> 访问，这也是预防 <code>XSS</code> 攻击的重要手段。</p> <p>相应的，对于 <code>CSRF</code> 攻击的预防，也有 <code>SameSite</code> 属性。</p> <p><code>SameSite</code> 可以设置为三个值，<code>Strict</code>、<code>Lax</code> 和 <code>None</code>。</p> <ul><li>a. 在 <code>Strict</code> 模式下，浏览器完全禁止第三方请求携带 <code>Cookie</code>。比如请求 <code>sanyuan.com</code> 网站只能在 <code>sanyuan.com</code> 域名当中请求才能携带 <code>Cookie</code>，在其他网站请求都不能。</li> <li>b. 在 <code>Lax</code> 模式，就宽松一点了，但是只能在 <code>get</code> 方法提交表单况或者 <code>a</code> 标签发送 <code>get</code> 请求的情况下可以携带 <code>Cookie</code>，其他情况均不能。</li> <li>c. 在 <code>None</code> 模式下，也就是默认模式，请求会自动携带上 <code>Cookie</code>。</li></ul> <h3 id="cookie-的安全问题"><a href="#cookie-的安全问题" class="header-anchor">#</a> Cookie 的安全问题?</h3> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p><code>Cookie</code> 在每次请求中都会被发送，如果不使用 <code>HTTPS</code> 并对其加密，其保存的信息很容易被窃取，导致安全风险<br> <code>Cookie</code> 每次请求自动发送的特性还会导致 <code>CSRF</code> 攻击的安全风险</p></div> <h3 id="cookie"><a href="#cookie" class="header-anchor">#</a> Cookie</h3> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <ol><li>可设置失效时间，没有设置的话，默认是关闭浏览器后失效</li> <li>存放数据大小：<code>4KB</code> 左右</li> <li>每次请求都会携带在 <code>HTTP</code> 头中，如果使用 <code>Cookie</code> 保存过多数据会带来性能问题</li> <li>需要自己封装，原生的 <code>Cookie</code> 接口不友好</li></ol></div> <h3 id="localstorage-sessionstorage"><a href="#localstorage-sessionstorage" class="header-anchor">#</a> localStorage / sessionStorage</h3> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <ol><li><code>localStorage</code>: 除非被手动清除，否则将会永久保存。
<code>sessionStorage</code>:  只在当前网页下有效，关闭页面或浏览器后就会被清除。</li> <li>都可以保存 <code>5MB</code> 的信息。</li> <li>都仅在客户端（即浏览器）中保存，不参与和服务器的通信</li> <li>原生接口比较友好，也可再次封装来对 <code>Object</code> 和 <code>Array</code> 有更好的支持</li></ol></div> <h2 id="了解-accept-相关字段？"><a href="#了解-accept-相关字段？" class="header-anchor">#</a> 了解 Accept 相关字段？</h2> <p>对于 <code>Accept</code> 系列字段的介绍分为四个部分: <code>数据格式</code>、<code>压缩方式</code>、<code>支持语言</code>和<code>字符集</code>。</p> <h3 id="数据格式"><a href="#数据格式" class="header-anchor">#</a> 数据格式</h3> <p>不过首先需要介绍一个标准——MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 <code>HTTP</code> 来说也是通用的。
因此，<code>HTTP</code> 从 <code>MIME type</code> 取了一部分来标记报文 <code>body</code> 部分的数据类型，这些类型体现在 <code>Content-Type</code> 这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用 <code>Accept</code> 字段。</p> <p>具体而言，这两个字段的取值可以分为下面几类:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>text： text/html, text/plain, text/css 等
image: image/gif, image/jpeg, image/png 等
audio/video: audio/mpeg, video/mp4 等
application: application/json, application/javascript, application/pdf, application/octet-stream
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="压缩方式"><a href="#压缩方式" class="header-anchor">#</a> 压缩方式</h3> <p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的 <code>Content-Encoding</code> 字段上， 同样的，接收什么样的压缩方式体现在了接受方的 <code>Accept-Encoding</code> 字段上。这个字段的取值有下面几种：</p> <p><code>gzip</code>: 当今最流行的压缩格式
<code>deflate</code>: 另外一种著名的压缩格式
<code>br</code>: 一种专门为 <code>HTTP</code> 发明的压缩算法</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>// 发送端
Content-Encoding: <span class="token function">gzip</span>
// 接收端
Accept-Encoding: <span class="token function">gzip</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="支持语言"><a href="#支持语言" class="header-anchor">#</a> 支持语言</h3> <p>对于发送方而言，还有一个 <code>Content-Language</code> 字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为 <code>Accept-Language</code>。如:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>// 发送端
Content-Language: zh-CN, zh, en
// 接收端
Accept-Language: zh-CN, zh, en
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="代码字符集"><a href="#代码字符集" class="header-anchor">#</a> 代码字符集</h3> <p>最后是一个比较特殊的字段, 在接收端对应为 <code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的 <code>Content-Charset</code>, 而是直接放在了 <code>Content-Type</code> 中，以 <code>charset</code> 属性指定。如:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>// 发送端
Content-Type: text/html<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
// 接收端
Accept-Charset: <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后以一张图来总结一下吧</p> <img src="/assets/img/3.662b8c3a.png" style="width: 80%"> <h2 id="说一说三次握手？"><a href="#说一说三次握手？" class="header-anchor">#</a> 说一说三次握手？</h2> <p><img src="/assets/img/4.30e02ae4.png" alt></p> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>三次握手:<br>
第一次握手：客户端向服务端发送 <code>SYN</code> 码数据包，表示客户端要求和服务端建立连接；<br>
第二次握手：服务端收到客户端的连接请求后，会发送 <code>ACK</code> 码数据包给客户端，表示客户端是否真的需要建立连接；<br>
第三次握手：客户端收到 <code>ACK</code> 码以后会检验是否正确，如果正确，客户端会再次发送 <code>ACK</code> 码给服务端，表示确认建立连接；<br>
(三次握手都成功以后才会建立连接，然后才会发送数据；)</p></div> <h3 id="为什么-tcp-连接需要3次握手，而不是两次"><a href="#为什么-tcp-连接需要3次握手，而不是两次" class="header-anchor">#</a> 为什么 TCP 连接需要3次握手，而不是两次</h3> <p>为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误</p> <h3 id="为什么-tcp-连接不是四次握手？"><a href="#为什么-tcp-连接不是四次握手？" class="header-anchor">#</a> 为什么 TCP 连接不是四次握手？</h3> <p>当然可以，三次握手的目的是确认双方发送和接收的能力，但为了解决问题，三次就足够了，再多用处就不大了。</p> <h2 id="说一说四次挥手？"><a href="#说一说四次挥手？" class="header-anchor">#</a> 说一说四次挥手？</h2> <p><img src="/assets/img/5.01644a58.png" alt></p> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>四次挥手：<br>
第一次挥手：客户端向服务端发送 <code>FIN</code> 码数据包，表示客户端的数据已经传递完了。<br>
第二次挥手：服务端收到 <code>FIN</code> 码后，会发送 <code>ACK</code> 码给客户端，表示服务端已经知道客户端传完了。<br>
客户端收到 <code>ACK</code> 码以后就会把数据传递给服务端的通道关闭；<br>
第三次挥手：服务端把响应的数据发送完毕后，会发送 <code>FIN</code> 码给客户端，表示服务端的响应数据已经发送完毕；<br>
第四次挥手：客户端收到 <code>FIN</code> 码后，会发送 <code>ACK</code> 码数据包给服务端，表示客户端已经知道数据发送完毕；<br>
服务端收到ACK码后，可以安心的把数据传递通道关闭掉。</p></div> <h3 id="为什么是四次挥手而不是三次？"><a href="#为什么是四次挥手而不是三次？" class="header-anchor">#</a> 为什么是四次挥手而不是三次？</h3> <p>因为服务端在接收到 <code>FIN</code> 码后, 往往不会立即返回 <code>FIN</code> 码, 必须等到服务端所有报文都发送完毕了，才能发 <code>FIN</code> 码，因此先发一个 <code>ACK</code> 码表示已经收到客户端的 <code>FIN</code> 码，延迟一段时间才发 <code>FIN</code> 码。这就造成了四次挥手。</p> <h3 id="如果是三次挥手会有什么问题？"><a href="#如果是三次挥手会有什么问题？" class="header-anchor">#</a> 如果是三次挥手会有什么问题？</h3> <p>等于说服务端将 <code>ACK</code> 和 <code>FIN</code> 的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为 <code>FIN</code> 码没有到达服务端，从而让客户端不断的重发 <code>FIN</code> 码。</p> <h3 id="为何客户端最后还等待-2msl？"><a href="#为何客户端最后还等待-2msl？" class="header-anchor">#</a> 为何客户端最后还等待 2MSL？</h3> <ul><li>即 <code>TIME - WAIT</code> 状态的作用是什么；</li> <li><code>MSL</code> = 最长报文段寿命（<code>Maximum Segment Lifetime</code>）</li></ul> <p>客户端需要保证最后一次发送的 <code>ACK</code> 码到服务器，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启 <code>2MSL</code> 计时</p> <h2 id="从输入url到页面展示，发生了什么"><a href="#从输入url到页面展示，发生了什么" class="header-anchor">#</a> 从输入URL到页面展示，发生了什么</h2> <div class="tip custom-block"><p class="custom-block-title">过程</p> <ul><li>浏览器根据 <code>URL</code> 进行 <code>DNS</code> 查询</li> <li>首先从 <code>DNS</code> 缓存中查询</li> <li>若没有在缓存中找到，则不停的向上一级请求 <code>DNS</code> 服务器</li> <li>获得 <code>IP</code> 地址，建立 <code>TCP</code> 连接</li> <li>构造 <code>HTTP</code> 请求报</li> <li>添加一些 <code>HTTP</code> 首部</li> <li>根据同源策略添加 <code>cookie</code></li> <li>在 <code>TCP</code> 连接上发送 <code>HTTP</code> 请求报文，等待响应</li> <li>服务器处理 <code>HTTP</code> 请求报文，返回 <code>HTTP</code> 响应报文</li> <li>浏览器处理服务器返回的 <code>HTTP</code> 响应报文，若为 <code>HTML</code> 则渲染页面，不包括脚本的简单渲染流程如下:
<ul><li><ol><li>解析 <code>DOM</code>、<code>CSSOM</code></li></ol></li> <li><ol start="2"><li>根据 <code>DOM</code>、<code>CSSOM</code> 计算渲染树</li></ol></li> <li><ol start="3"><li>根据渲染树进行布局</li></ol></li> <li><ol start="4"><li>重绘，至此，用户可以看到页面了</li></ol></li></ul></li></ul></div> <p><strong>DNS解析(递归查找)</strong></p> <p>DNS缓存 -&gt; 本地域名服务器 -&gt; 根域名服务器 -&gt; 顶级域名服务器 -&gt; 权限域名服务器<br>
DNS缓存 &lt;- 本地域名服务器 &lt;- 根域名服务器 &lt;- 顶级域名服务器 &lt;- 权限域名服务器</p> <h2 id="什么是-tcp-和-udp？"><a href="#什么是-tcp-和-udp？" class="header-anchor">#</a> 什么是 TCP 和 UDP？</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p><code>TCP</code>（<code>Transmission Control Protocol</code>，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。<br> <code>UDP</code> （<code>User Datagram Protocol</code>，用户数据包协议），是一种面向无连接的、不可靠的、基于数据包的传输层通信协议，通过端口号把数据包分发给正确的程序</p></div> <div class="tip custom-block"><p class="custom-block-title">具体分析</p> <p>具体来分析，和 <code>UDP</code> 相比，<code>TCP</code> 有三大核心特性:</p> <ul><li><code>面向连接</code> 所谓的连接，指的是客户端和服务端的连接，在双方互相通信之前，<code>TCP</code> 需要三次握手建立连接，而 <code>UDP</code> 没有相应建立连接的过程。</li> <li><code>可靠性</code> <code>TCP</code> 花了非常多的功夫保证连接的可靠，这个可靠性体现在两个方面，一个是有状态，另一个是可控制。
<code>TCP</code> 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。
当意识到丢包了或者网络环境不佳，<code>TCP</code> 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。
相应的，<code>UDP</code> 就是无状态, 不可控的。</li> <li><code>基于字节流</code> <code>UDP</code> 的数据传输是基于数据包的，这是因为仅仅只是继承了 <code>IP</code> 层的特性，而 <code>TCP</code> 为了维护状态，将一个个 <code>IP</code> 包变成了字节流。</li></ul></div> <h2 id="对于定长和不定长的数据，http-是怎么传输的？"><a href="#对于定长和不定长的数据，http-是怎么传输的？" class="header-anchor">#</a> 对于定长和不定长的数据，HTTP 是怎么传输的？</h2> <h3 id="定长包体"><a href="#定长包体" class="header-anchor">#</a> 定长包体</h3> <p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p> <p>如果设置的 <code>Content-Length</code> 大于实际的长度，则会无法显示，如果小于实际的长度，则浏览器会进行截断。</p> <h3 id="不定长包体"><a href="#不定长包体" class="header-anchor">#</a> 不定长包体</h3> <p>可以设置另一个 <code>HTTP</code> 头部字段 -&gt; <code>Transfer-Encoding: chunked</code></p> <p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p> <ul><li><code>Content-Length</code> 字段会被忽略</li> <li>基于长连接持续推送动态内容</li></ul> <h2 id="http-如何处理大文件的传输？"><a href="#http-如何处理大文件的传输？" class="header-anchor">#</a> HTTP 如何处理大文件的传输？</h2> <h3 id="如何支持"><a href="#如何支持" class="header-anchor">#</a> 如何支持</h3> <p>当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头: Accept-Ranges: none , 用来告知客户端这边是支持范围请求的。</p> <h3 id="range-字段拆解"><a href="#range-字段拆解" class="header-anchor">#</a> Range 字段拆解</h3> <p>而对于客户端而言，它需要指定请求哪一部分，通过Range这个请求头字段确定，格式为bytes=x-y。接下来就来讨论一下这个 Range 的书写格式:</p> <ul><li>0-499表示从开始到第 499 个字节。</li> <li>500- 表示从第 500 字节到文件终点。</li> <li>-100表示文件的最后100个字节。</li></ul> <p>服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回416错误码，否则读取相应片段，返回206状态码。</p> <p>同时，服务器需要添加Content-Range字段，这个字段的格式根据请求头中Range字段的不同而有所差异。</p> <p>具体来说，请求单段数据和请求多段数据，响应头是不一样的。</p> <p>举个例子:</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token comment">// 单段数据</span>
Range<span class="token operator">:</span> bytes=<span class="token number">0</span><span class="token number">-9</span>
<span class="token comment">// 多段数据</span>
Range<span class="token operator">:</span> bytes=<span class="token number">0</span><span class="token number">-9</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token number">-39</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="单段数据"><a href="#单段数据" class="header-anchor">#</a> 单段数据</h3> <p>对于单段数据的请求，返回的响应如下:</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code>HTTP/<span class="token number">1.1</span> <span class="token number">206</span> Partial Content
Content-Length<span class="token operator">:</span> <span class="token number">10</span>
Accept-Ranges<span class="token operator">:</span> bytes
Content-Range<span class="token operator">:</span> bytes <span class="token number">0</span><span class="token number">-9</span>/<span class="token number">100</span>

i am xxxxx
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>值得注意的是Content-Range字段，0-9表示请求的返回，100表示资源的总大小，很好理解。</p> <h2 id="什么是-https？"><a href="#什么是-https？" class="header-anchor">#</a> 什么是 HTTPS？</h2> <p><code>HTTPS</code> 并不是一个新的协议, 而是一个加强版的 <code>HTTP</code>。其原理是在 <code>HTTP</code> 和 <code>TCP</code> 之间建立了一个中间层，当 <code>HTTP</code> 和 <code>TCP</code> 通信时并不是像以前那样直接通信，而是直接经过了一个中间层进行加密，将加密后的数据传给 <code>TCP</code> 响应的，<code>TCP</code> 必须将数据解密，才能传给上面的 <code>HTTP</code>。这个中间层也叫安全层。安全层的核心就是对数据加解密。</p> <h2 id="传统-rsa-加密算法？"><a href="#传统-rsa-加密算法？" class="header-anchor">#</a> 传统 RSA 加密算法？</h2> <p><code>HTTPS</code> 并不是一个新的协议, 它在 <code>HTTP</code> 和 <code>TCP</code> 的传输中建立了一个安全层，利用<strong>对称加密和非对称机密结合数字证书认证</strong>的方式，让传输过程的安全性大大提高。</p> <h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="header-anchor">#</a> 对称加密和非对称加密</h3> <p>对称加密是最简单的方式，指的是加密和解密用的是同样的<strong>密钥</strong>。</p> <p>而对于非对称加密，如果有 A、 B 两把密钥，如果用 A 加密过的数据只能用 B 解密，反之，如果用 B 加密过的数据只能用 A 解密。</p> <p><strong>加解密过程</strong></p> <p>接着我们来谈谈浏览器和服务器进行协商加解密的过程。</p> <ul><li>首先，浏览器会给服务器发送一个随机数 <code>client_random</code> 和加密方法列表。</li> <li>服务器接收后给浏览器返回另一个随机数 <code>server_random</code> 和加密方法。</li> <li>现在，两者拥有三样相同的凭证: <code>client_random</code>、<code>server_random</code> 和加密方法。</li> <li>接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号</li></ul> <p><strong>各自应用的效果</strong></p> <p>如果用对称加密的方式，那么第三方可以在中间获取到 <code>client_random</code>、<code>server_random</code> 和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。</p> <p>那能不能只用非对称加密呢？理论上是可以的，但实际上非对称加密需要的计算量非常大，对于稍微大一点的数据即使用最快的处理器也非常耗时。后面有机会给大家分享一下 <code>RSA</code> 非对称加密算法的原理，大家就会有更加直观的认识，这里我们先不深究。</p> <h3 id="对称加密和非对称加密的结合"><a href="#对称加密和非对称加密的结合" class="header-anchor">#</a> 对称加密和非对称加密的结合</h3> <p><strong>整个流程:</strong></p> <ul><li>浏览器向服务器发送 <code>client_random</code> 和加密方法列表。</li> <li>服务器接收到，返回 <code>server_random</code>、加密方法以及公钥。</li> <li>浏览器接收，接着生成另一个随机数 <code>pre_random</code>, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)</li> <li>服务器用私钥解密这个被加密后的 <code>pre_random</code>。</li></ul> <p>现在浏览器和服务器有三样相同的凭证: <code>client_random</code>、<code>server_random</code> 和 <code>pre_random</code>。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。</p> <p>然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。</p> <p>这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而拿不到 <code>pre_random</code>，也就无法生成最终的密钥了。</p> <p>回头比较一下和单纯的使用非对称加密, 这种方式做了什么改进呢？本质上是防止了私钥加密的数据外传。单独使用非对称加密，最大的漏洞在于服务器传数据给浏览器只能用私钥加密，这是危险产生的根源。利用对称和非对称加密结合的方式，就防止了这一点，从而保证了安全。</p> <h3 id="添加数字证书"><a href="#添加数字证书" class="header-anchor">#</a> 添加数字证书</h3> <p>尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 <code>DNS</code> 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。</p> <p>事实上 <code>HTTPS</code> 在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。</p> <p><strong>传输过程</strong></p> <p>为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫 <code>CA(Certificate Authority)</code>, 认证通过后 <code>CA</code> 会给服务器颁发数字证书。</p> <p>这个数字证书有两个作用:</p> <ul><li>服务器向浏览器证明自己的身份。</li> <li>把公钥传给浏览器。</li></ul> <p>这个验证的过程发生在什么时候呢？</p> <p>当服务器传送 <code>server_random</code>、加密方法的时候，顺便会带上数字证书(包含了公钥), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p> <p>现在我们来梳理一下 <code>HTTPS</code> 最终的加解密过程:</p> <p><img src="/assets/img/6.68d466b7.jpg" alt></p> <p><strong>认证过程</strong></p> <p>浏览器拿到数字证书后，如何来对证书进行认证呢？</p> <p>首先，会读取证书中的明文内容。<code>CA</code> 进行数字证书的签名时会保存一个 <code>Hash</code> 函数，用这个函数来计算明文内容得到信息 <code>A</code>，然后用公钥解密明文内容得到信息 <code>B</code>，两份信息做比对，一致则表示认证合法。</p> <p>当然有时候对于浏览器而言，它不知道哪些 <code>CA</code> 是值得信任的，因此会继续查找 <code>CA</code> 的上级 <code>CA</code>，以同样的信息比对方式验证上级 <code>CA</code> 的合法性。一般根级的 <code>CA</code> 会内置在操作系统当中，当然如果向上找没有找到根级的 <code>CA</code>，那么将被视为不合法。</p> <h2 id="tls1-2-握手的过程？"><a href="#tls1-2-握手的过程？" class="header-anchor">#</a> TLS1.2 握手的过程？</h2> <p><code>HTTPS</code>，其实它并不是一个新的协议，而是在 <code>HTTP</code> 下面增加了一层 <code>SSL/TLS</code> 协议，简单的讲，<code>HTTPS = HTTP + SSL/TLS</code>。</p> <p><code>SSL</code> 即安全套接层（<code>Secure Sockets Layer</code>），在 <code>OSI</code> 七层模型中处于会话层(第 <code>5</code> 层)。之前 <code>SSL</code> 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 <code>TLS</code>（传输层安全，<code>Transport Layer Security</code>），并被当做 <code>TLS1.0</code> 的版本，准确地说，<code>TLS1.0 = SSL3.1。</code></p> <h3 id="tls-1-2-握手过程"><a href="#tls-1-2-握手过程" class="header-anchor">#</a> TLS 1.2 握手过程</h3> <p><img src="/assets/img/7.5303dab1.jpg" alt></p> <p><strong>具体步骤如下：</strong>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p> <ul><li>首先，浏览器向服务器发送 <code>client_random</code>、<code>TLS</code> 版本、加密套件列表。
=======</li> <li>浏览器向服务器发送 <code>client_random</code>、<code>TLS</code> 版本、加密套件列表。</li></ul> <blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>51bcde1a0d1c1f2a72f5fc4e0add24420e0bf711</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote> <ul><li>服务器接收到，并返回 <code>server_random</code>、<code>server_params</code>、确认 TLS 版本、加密套件列表、数字证书。</li> <li>客户端验证服务端传来的证书和签名是否通过，如果验证通过，则传递 <code>client_params</code> 这个参数给服务器，并通过 <code>ECDHE</code> 算法计算出 <code>pre_random</code>, 最后将 <code>client_random</code>、<code>server_random</code> 和 <code>pre_random</code> 这三个参数通过一个伪随机数函数来计算出最终的 <code>secret</code>。</li> <li>服务端开始用 <code>ECDHE</code> 算法生成 <code>pre_random</code>，接着用和客户端同样的伪随机数函数生成最后的 <code>secret</code>。</li></ul> <p><strong>数字证书认证过程？</strong></p> <p><strong>哈希摘要算法</strong>，将服务端的证书信息通过这个算法生成一个摘要(可以理解为比较短的字符串)，用来标识这个服务端的身份，用<strong>私钥加密</strong>后把加密后的标识和自己的公钥传给客户端。客户端拿到这个<strong>公钥来解密</strong>，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务端的身份。这也就是所谓数字签名的原理。其中除了哈希算法，最重要的过程是<strong>私钥加密，公钥解密</strong>。</p> <h2 id="tls1-3-握手的过程？"><a href="#tls1-3-握手的过程？" class="header-anchor">#</a> TLS1.3 握手的过程？</h2> <p><strong>握手改进</strong></p> <p><img src="/assets/img/8.13d2a002.jpg" alt></p> <p>大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到client_params，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算secret，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。</p> <p>这种 TLS 1.3 握手方式也被叫做1-RTT握手。但其实这种1-RTT的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。</p> <p><strong>具体步骤如下：</strong></p> <ul><li>首先，浏览器向服务器发送 <code>client_params</code>、<code>client_random</code>、<code>TLS</code> 版本、加密套件列表。</li> <li>服务器接收到，并返回 <code>server_random</code>、<code>server_params</code>、确认 TLS 版本、加密套件列表、服务器使用的证书，并服务端开始用 <code>ECDHE</code> 算法生成 <code>pre_random</code>，并通过这三个参数通过一个伪随机数函数来计算出最终的 <code>secret</code>。</li> <li>客户端验证服务端传来的证书和签名是否通过，如果验证通过，则通过 <code>ECDHE</code> 算法计算出 <code>pre_random</code>, 最后将 <code>client_random</code>、<code>server_random</code> 和 <code>pre_random</code> 这三个参数通过一个伪随机数函数来计算出最终的 <code>secret</code>。</li></ul> <p><code>TLS1.3</code> 在 <code>TLS1.2</code> 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 <code>PSK</code> 做到了 <code>0-RTT</code> 连接。</p> <h2 id="xss-讲一下？"><a href="#xss-讲一下？" class="header-anchor">#</a> XSS 讲一下？</h2> <p><code>XSS</code> 攻击, 全称是 <code>Cross Site Scripting</code>(即跨站脚本攻击), 是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括:</p> <ul><li>一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。</li> <li>两个利用: 利用 <code>CSP</code>，利用 <code>Cookie</code> 的 <code>HttpOnly</code> 属性。</li></ul> <h2 id="csrf-攻击讲一下？"><a href="#csrf-攻击讲一下？" class="header-anchor">#</a> CSRF 攻击讲一下？</h2> <p><code>CSRF(Cross-site request forgery)</code>, 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</p> <p><code>CSRF</code> 攻击一般会有三种方式:</p> <ul><li>自动 <code>GET</code> 请求</li> <li>自动 <code>POST</code> 请求</li> <li>诱导点击发送 <code>GET</code> 请求。</li></ul> <p>防范措施: 利用 <code>Cookie</code> 的 <code>SameSite</code> 属性、验证来源站点和 <code>CSRF Token</code>。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.f426d84b.js" defer></script><script src="/assets/js/2.45113de2.js" defer></script>
  </body>
</html>
