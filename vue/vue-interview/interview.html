<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 面试 | Dai&#39;s blog</title>
    <meta name="description" content="学海无涯，永无止尽">
    <link rel="icon" href="/images/photo1.jpg">
  <link rel="manifest" href="/images/photo1.jpg">
  <link rel="apple-touch-icon" href="/images/photo1.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.7a8c588f.css" as="style"><link rel="preload" href="/assets/js/app.f426d84b.js" as="script"><link rel="preload" href="/assets/js/10.598aec70.js" as="script"><link rel="prefetch" href="/assets/js/11.0a334ef2.js"><link rel="prefetch" href="/assets/js/12.f83989bb.js"><link rel="prefetch" href="/assets/js/13.dd91d8f5.js"><link rel="prefetch" href="/assets/js/14.a621ceac.js"><link rel="prefetch" href="/assets/js/15.ad3aee55.js"><link rel="prefetch" href="/assets/js/16.7970749b.js"><link rel="prefetch" href="/assets/js/17.e27753d2.js"><link rel="prefetch" href="/assets/js/18.1fe75540.js"><link rel="prefetch" href="/assets/js/19.0c5bd26b.js"><link rel="prefetch" href="/assets/js/2.45113de2.js"><link rel="prefetch" href="/assets/js/20.ec4acfac.js"><link rel="prefetch" href="/assets/js/21.1e0b9fa7.js"><link rel="prefetch" href="/assets/js/22.0f634031.js"><link rel="prefetch" href="/assets/js/23.c4ff9424.js"><link rel="prefetch" href="/assets/js/24.6febaf73.js"><link rel="prefetch" href="/assets/js/25.49be9a43.js"><link rel="prefetch" href="/assets/js/26.8a9a71ec.js"><link rel="prefetch" href="/assets/js/27.17146263.js"><link rel="prefetch" href="/assets/js/28.e0a2e3c6.js"><link rel="prefetch" href="/assets/js/29.dc94d080.js"><link rel="prefetch" href="/assets/js/3.3d736d2f.js"><link rel="prefetch" href="/assets/js/30.f72dd6e2.js"><link rel="prefetch" href="/assets/js/31.42ec33bb.js"><link rel="prefetch" href="/assets/js/32.e00a4c90.js"><link rel="prefetch" href="/assets/js/33.cf1f4856.js"><link rel="prefetch" href="/assets/js/34.f8c9eb5c.js"><link rel="prefetch" href="/assets/js/35.b629392d.js"><link rel="prefetch" href="/assets/js/36.ae67625f.js"><link rel="prefetch" href="/assets/js/37.34e4a8dd.js"><link rel="prefetch" href="/assets/js/38.aa0e663a.js"><link rel="prefetch" href="/assets/js/39.3764f79c.js"><link rel="prefetch" href="/assets/js/4.1ac1a89c.js"><link rel="prefetch" href="/assets/js/40.6372fb99.js"><link rel="prefetch" href="/assets/js/5.6477920e.js"><link rel="prefetch" href="/assets/js/6.d0ca8e10.js"><link rel="prefetch" href="/assets/js/7.908bb025.js"><link rel="prefetch" href="/assets/js/8.53a275f3.js"><link rel="prefetch" href="/assets/js/9.bffbc9ba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7a8c588f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dai's blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JS/JS-interview/interview.html" class="nav-link">JS核心面试</a></li><li class="dropdown-item"><!----> <a href="/JS/JS-handwriting/handwriting.html" class="nav-link">JS核心手写</a></li><li class="dropdown-item"><!----> <a href="/JS/Promise/promise.html" class="nav-link">Promise面试题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CSS/CSS-interview/interview.html" class="nav-link">CSS核心面试</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-layout/layout.html" class="nav-link">CSS常见布局</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-flex/flex.html" class="nav-link">Flex布局</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue-basic/basic.html" class="nav-link">vue2.0基础</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-advanced/advanced.html" class="nav-link">vue2.0进阶</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-interview/interview.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">vue核心面试</a></li><li class="dropdown-item"><!----> <a href="/vue/sourceCode/intro/intro.html" class="nav-link">vue源码解析</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/webpack/webpack_basic.html" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/other/typeScript/base.html" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/other/git/git.html" class="nav-link">Git 操作</a></li><li class="dropdown-item"><!----> <a href="/other/network/http.html" class="nav-link">计算机网络</a></li></ul></div></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JS/JS-interview/interview.html" class="nav-link">JS核心面试</a></li><li class="dropdown-item"><!----> <a href="/JS/JS-handwriting/handwriting.html" class="nav-link">JS核心手写</a></li><li class="dropdown-item"><!----> <a href="/JS/Promise/promise.html" class="nav-link">Promise面试题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSS</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CSS/CSS-interview/interview.html" class="nav-link">CSS核心面试</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-layout/layout.html" class="nav-link">CSS常见布局</a></li><li class="dropdown-item"><!----> <a href="/CSS/CSS-flex/flex.html" class="nav-link">Flex布局</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue-basic/basic.html" class="nav-link">vue2.0基础</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-advanced/advanced.html" class="nav-link">vue2.0进阶</a></li><li class="dropdown-item"><!----> <a href="/vue/vue-interview/interview.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">vue核心面试</a></li><li class="dropdown-item"><!----> <a href="/vue/sourceCode/intro/intro.html" class="nav-link">vue源码解析</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/webpack/webpack_basic.html" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/other/typeScript/base.html" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/other/git/git.html" class="nav-link">Git 操作</a></li><li class="dropdown-item"><!----> <a href="/other/network/http.html" class="nav-link">计算机网络</a></li></ul></div></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>vue 面试</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/vue/vue-interview/interview.html#_1、mvvm-相关问题" class="sidebar-link">1、MVVM 相关问题?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、mvvm-讲一下" class="sidebar-link">1、MVVM 讲一下?</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、mvvm-响应式数据更新" class="sidebar-link">2、MVVM 响应式数据更新?</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、mvc-数据更新流程" class="sidebar-link">3、MVC 数据更新流程?</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_4、mvvm-模式和-mvc-的不同点？" class="sidebar-link">4、MVVM 模式和 MVC 的不同点？</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_2、vue-的优缺点？" class="sidebar-link">2、Vue 的优缺点？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_3、vue-的核心思想？" class="sidebar-link">3、Vue 的核心思想？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_4、vue-中的响应式原理缺陷？" class="sidebar-link">4、Vue 中的响应式原理缺陷？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、对于对象" class="sidebar-link">1、对于对象</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、对于数组" class="sidebar-link">2、对于数组</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_5、vue-生命周期" class="sidebar-link">5、Vue 生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、什么是生命周期函数" class="sidebar-link">1、什么是生命周期函数?</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、vue-生命周期的作用是什么？" class="sidebar-link">2、Vue 生命周期的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、vue-生命周期总共有几个阶段？" class="sidebar-link">3、Vue 生命周期总共有几个阶段？</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_4、vue-生命周期触发的时机？" class="sidebar-link">4、Vue 生命周期触发的时机？</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_6、v-show-与-v-if-区别？" class="sidebar-link">6、v-show 与 v-if 区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_7、说说你对-spa-单页面的理解" class="sidebar-link">7、说说你对 SPA 单页面的理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_8、computed-和-watch-的区别？" class="sidebar-link">8、computed 和 watch 的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_9、vue-组件-data-为什么必须是函数" class="sidebar-link">9、Vue 组件 data 为什么必须是函数?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_10、谈谈-keep-alive-的理解？" class="sidebar-link">10、谈谈 keep-alive 的理解？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_11、vue-中的-key-有什么作用？" class="sidebar-link">11、Vue 中的 key 有什么作用？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_12、vue-组件通信方式" class="sidebar-link">12、Vue 组件通信方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_13、请介绍一下你对-vuex-的理解？" class="sidebar-link">13、请介绍一下你对 Vuex 的理解？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、响应式" class="sidebar-link">1、响应式</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、模块" class="sidebar-link">2、模块</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、vuex-解决了什么问题？" class="sidebar-link">3、Vuex 解决了什么问题？</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_14、说说对-vue-router-的理解？" class="sidebar-link">14、说说对 vue-router 的理解？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、hash-模式的实现原理" class="sidebar-link">1、hash 模式的实现原理</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、history-模式的实现原理" class="sidebar-link">2、history 模式的实现原理</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_15、vue-router-有哪几种导航守卫" class="sidebar-link">15、vue-router 有哪几种导航守卫?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、全局守卫" class="sidebar-link">1、全局守卫</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、路由独享守卫" class="sidebar-link">2、路由独享守卫</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、路由组件内的守卫" class="sidebar-link">3、路由组件内的守卫</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_16、nexttick实现原理" class="sidebar-link">16、nextTick实现原理?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_17、vue-的双向数据绑定原理" class="sidebar-link">17、Vue 的双向数据绑定原理?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_18、怎样理解-vue-的单向数据流？" class="sidebar-link">18、怎样理解 Vue 的单向数据流？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_19、v-model-的原理？" class="sidebar-link">19、v-model 的原理？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_20、-vue中是如何检测数组变化" class="sidebar-link">20、 Vue中是如何检测数组变化?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_21、proxy-与-defineproperty-对比" class="sidebar-link">21、Proxy 与 defineProperty 对比</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_22、vm-set-解决对象响应式" class="sidebar-link">22、vm.$set() 解决对象响应式?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue-interview/interview.html#_23、虚拟-dom-概念及实现原理？" class="sidebar-link">23、虚拟 DOM 概念及实现原理？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、什么是虚拟-dom" class="sidebar-link">1、什么是虚拟 DOM</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、为什么要使用虚拟-dom？" class="sidebar-link">2、为什么要使用虚拟 DOM？</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、虚拟-dom-的作用" class="sidebar-link">3、虚拟 DOM 的作用</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_4、diff-算法" class="sidebar-link">4、diff 算法</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_24、vue-项目优化？" class="sidebar-link">24、Vue 项目优化？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、代码层面的优化" class="sidebar-link">1、代码层面的优化</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、webpack-层面的优化" class="sidebar-link">2、Webpack 层面的优化</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、基础的-web-技术的优化" class="sidebar-link">3、基础的 Web 技术的优化</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_25、vue3-0-特性的了解？" class="sidebar-link">25、vue3.0 特性的了解？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、监测机制的改变" class="sidebar-link">1、监测机制的改变</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、新的-observer-特性" class="sidebar-link">2、新的 observer 特性</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、模板" class="sidebar-link">3、模板</a></li></ul></li><li><a href="/vue/vue-interview/interview.html#_26、vue3-0-比起-vue2-x-的优势？" class="sidebar-link">26、Vue3.0 比起 Vue2.x 的优势？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_1、性能比2-x快1-2～2倍" class="sidebar-link">1、性能比2.x快1.2～2倍</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_2、按需编译，体积比vue2-x更小（tree-shaking）" class="sidebar-link">2、按需编译，体积比Vue2.x更小（Tree shaking）</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_3、compostion-api-组合api-注入api" class="sidebar-link">3、Compostion API: 组合API/注入API</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_4、更好的ts支持" class="sidebar-link">4、更好的TS支持</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_5、自定义渲染api（custom-renderer-api）" class="sidebar-link">5、自定义渲染API（Custom Renderer API）</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_6、更先进的组件" class="sidebar-link">6、更先进的组件</a></li><li class="sidebar-sub-header"><a href="/vue/vue-interview/interview.html#_7、更快的开发体验（vite开发构建工具）" class="sidebar-link">7、更快的开发体验（vite开发构建工具）</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-面试"><a href="#vue-面试" class="header-anchor">#</a> vue 面试</h1> <h2 id="_1、mvvm-相关问题"><a href="#_1、mvvm-相关问题" class="header-anchor">#</a> 1、MVVM 相关问题?</h2> <h3 id="_1、mvvm-讲一下"><a href="#_1、mvvm-讲一下" class="header-anchor">#</a> 1、MVVM 讲一下?</h3> <ul><li><code>M - Model</code>，代表数据模型，用来定义数据修改和操作的业务逻辑。</li> <li><code>V - View</code>，代表 <code>UI</code> 组件，它负责将数据模型转化为 <code>UI</code> 展示出来。</li> <li><code>VM - ViewModel</code>，监听数据模型的改变和控制视图行为，简单理解就是一个同步 <code>View</code> 和 <code>Model</code> 的对象，连接 <code>View</code> 和 <code>Model</code>。</li></ul> <h3 id="_2、mvvm-响应式数据更新"><a href="#_2、mvvm-响应式数据更新" class="header-anchor">#</a> 2、MVVM 响应式数据更新?</h3> <ul><li><code>View</code> 接收用户交互请求。</li> <li><code>View</code> 将请求转交给 <code>ViewModel</code>。</li> <li><code>ViewModel</code> 操作 <code>Model</code> 数据更新。</li> <li><code>Model</code> 更新完数据，通知 <code>ViewModel</code> 数据发生变化。</li> <li><code>ViewModel</code> 更新 <code>View</code> 数据。</li></ul> <h3 id="_3、mvc-数据更新流程"><a href="#_3、mvc-数据更新流程" class="header-anchor">#</a> 3、MVC 数据更新流程?</h3> <ul><li><code>View</code> 接收用户交互请求。</li> <li><code>View</code> 将请求转交给 <code>Controller</code>。</li> <li><code>Controller</code> 操作 <code>Model</code> 进行数据更新保存。</li> <li>数据更新保存之后，<code>Model</code> 会通知 <code>View</code> 更新。</li> <li><code>View</code> 更新变化数据使用户得到反馈。</li></ul> <h3 id="_4、mvvm-模式和-mvc-的不同点？"><a href="#_4、mvvm-模式和-mvc-的不同点？" class="header-anchor">#</a> 4、MVVM 模式和 MVC 的不同点？</h3> <ul><li><code>ViewModel</code> 替换了 <code>Controller</code>，在 <code>UI</code> 层之下。</li> <li><code>ViewModel</code> 向 <code>View</code> 暴露了它所需要的数据和指令对象。</li> <li><code>ViewModel</code> 接收来自 <code>Model</code> 的数据。</li></ul> <p>概括起来，<code>MVVM</code> 是由 <code>MVC</code> 发展而来，通过在 <code>Model</code> 之上而在 <code>View</code> 之下增加一个非视觉的组件将来自 <code>Model</code> 的数据映射到 <code>View</code> 中。</p> <h2 id="_2、vue-的优缺点？"><a href="#_2、vue-的优缺点？" class="header-anchor">#</a> 2、Vue 的优缺点？</h2> <p><strong>优点</strong></p> <ul><li>创建单页面应用的轻量级 <code>Web</code> 应用框架</li> <li>简单易用</li> <li>双向数据绑定</li> <li>组件化的思想</li> <li>虚拟 <code>DOM</code></li> <li>数据驱动视图</li></ul> <p><strong>缺点</strong></p> <ul><li>不支持 <code>IE8</code>（现阶段只能勉强凑出这么半点😂）</li></ul> <h2 id="_3、vue-的核心思想？"><a href="#_3、vue-的核心思想？" class="header-anchor">#</a> 3、Vue 的核心思想？</h2> <p><code>Vue.js</code> 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 <code>DOM</code>，而是通过修改数据。
它相比我们传统的前端开发，如使用 <code>jQuery</code> 等前端库直接修改 <code>DOM</code>，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 <code>DOM</code> 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 <code>DOM</code>，这样的代码非常利于维护。</p> <h2 id="_4、vue-中的响应式原理缺陷？"><a href="#_4、vue-中的响应式原理缺陷？" class="header-anchor">#</a> 4、Vue 中的响应式原理缺陷？</h2> <h3 id="_1、对于对象"><a href="#_1、对于对象" class="header-anchor">#</a> 1、对于对象</h3> <p><code>Vue</code> 不能检测 <code>属性</code> 的添加或移除。由于 <code>Vue</code> 会在初始化实例时通过 <code>Object.defineProperty()</code> 对 <code>属性</code>
执行 <code>getter/setter</code> 转化，所以 <code>属性</code> 必须在 <code>data</code> 对象上存在才能让 <code>Vue</code> 将它转换为响应式的。<br> <strong>避免方法：</strong></p> <ul><li><ol><li><code>Vue.set(object, propertyName, value)</code> 或 <code>vm.$set(object, propertyName, value)</code></li></ol></li> <li><ol start="2"><li><code>this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</code></li></ol></li></ul> <h3 id="_2、对于数组"><a href="#_2、对于数组" class="header-anchor">#</a> 2、对于数组</h3> <p><code>Vue</code> 不能检测以下数组的变动：</p> <ul><li><ol><li>当你使用索引的方式直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li></ol></li> <li><ol start="2"><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol></li></ul> <p><strong>避免方法：</strong></p> <ul><li><ol><li><code>Vue.set(vm.items, indexOfItem, newValue)</code> 或 <code>vm.items.splice(indexOfItem, 1, newValue)</code>, <code>vm.$set(vm.items, indexOfItem, newValue)</code></li></ol></li> <li><ol start="2"><li><code>vm.items.splice(newLength)</code></li></ol></li></ul> <h2 id="_5、vue-生命周期"><a href="#_5、vue-生命周期" class="header-anchor">#</a> 5、Vue 生命周期</h2> <h3 id="_1、什么是生命周期函数"><a href="#_1、什么是生命周期函数" class="header-anchor">#</a> 1、什么是生命周期函数?</h3> <p>生命周期函数，指的是 <code>Vue</code> 实例的创建、更新、销毁三个阶段所触发执行的函数。也就是从开始创建、初始化数据、编译模板、挂载 <code>DOM</code>-&gt;渲染、更新-&gt;渲染、卸载等一系列过程，称为 <code>Vue</code> 的生命周期。</p> <h3 id="_2、vue-生命周期的作用是什么？"><a href="#_2、vue-生命周期的作用是什么？" class="header-anchor">#</a> 2、Vue 生命周期的作用是什么？</h3> <p>它的生命周期有多个事件钩子，让我们在控制整个 <code>Vue</code> 实例的过程时更容易形成良好的逻辑。</p> <h3 id="_3、vue-生命周期总共有几个阶段？"><a href="#_3、vue-生命周期总共有几个阶段？" class="header-anchor">#</a> 3、Vue 生命周期总共有几个阶段？</h3> <p>它可以总共分为 <code>8</code> 个阶段：创建前 / 后、载入前 / 后、更新前 / 后、销毁前 / 后</p> <h3 id="_4、vue-生命周期触发的时机？"><a href="#_4、vue-生命周期触发的时机？" class="header-anchor">#</a> 4、Vue 生命周期触发的时机？</h3> <p><strong>1. 第一次页面加载会触发哪几个钩子？</strong><br> <code>beforeCreate、created、beforeMount、mounted</code> 这几个钩子</p> <p><strong>2. DOM 渲染在哪个周期中就已经完成？</strong><br> <code>DOM</code> 渲染在 <code>mounted</code> 就已经完成了</p> <p><strong>3. 每个生命周期适合哪些场景？</strong></p> <ul><li><code>beforeCreate</code>: 可以在这加个 <code>loading</code> 事件，在加载实例时触发</li> <li><code>created</code>: 初始化完成时的事件写在这里，如在这结束 <code>loading</code> 事件，异步请求也适宜在这里调用</li> <li><code>mounted</code>: 挂载元素，获取到 <code>DOM</code> 节点</li> <li><code>updated</code>: 如果对数据统一处理，在这里写上相应函数</li> <li><code>beforeDestroy</code>: 可以做一个确认停止事件的确认框</li> <li><code>nextTick</code>: 更新数据后立即操作 <code>DOM</code></li></ul> <p><strong>4. 生命周期钩子函数代表的意思？</strong></p> <ul><li><code>beforeCreate</code> 阶段：<code>vue</code> 实例的挂载元素 <code>el</code> 和数据对象 <code>data</code> 都是 <code>undefined</code>， 还没有初始化。</li> <li><code>created</code> 阶段：<code>vue</code> 实例的数据对象 <code>data</code> 有了，可以访问里面的数据和方法， 未挂载到 <code>DOM，el</code> 还没有</li> <li><code>beforeMount</code> 阶段：<code>vue</code> 实例的 <code>el</code> 和 <code>data</code> 都初始化了，但是挂载之前为虚拟的 <code>dom</code> 节点</li> <li><code>mounted</code> 阶段：<code>vue</code> 实例挂载到真实 <code>DOM</code> 上，此时可以获取 <code>DOM</code> 节点</li> <li><code>beforeUpdate</code> 阶段：响应式数据更新时调用，发生在虚拟 <code>DOM</code> 打补丁之前， 适合在数据更新之前访问现有的 <code>DOM</code>，比如手动移除已添加的事件监听器</li> <li><code>updated</code> 阶段：虚拟 <code>DOM</code> 重新渲染和打补丁之后调用，此时可以获取新的 <code>DOM</code> 节点，避免在这个钩子函数中操作数据，防止死循环</li> <li><code>beforeDestroy</code> 阶段：实例销毁前调用，实例还可以用，<code>this</code> 能获取到实例，常用于销毁定时器，解绑事件</li> <li><code>destroyed</code> 阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li></ul> <h2 id="_6、v-show-与-v-if-区别？"><a href="#_6、v-show-与-v-if-区别？" class="header-anchor">#</a> 6、v-show 与 v-if 区别？</h2> <ul><li><code>v-show</code> 是 <code>CSS</code> 切换，<code>v-if</code> 是完整的销毁和创建</li> <li>使用频繁时用 <code>v-show</code>，运行时较少改变时使用 <code>v-if</code></li></ul> <h2 id="_7、说说你对-spa-单页面的理解"><a href="#_7、说说你对-spa-单页面的理解" class="header-anchor">#</a> 7、说说你对 SPA 单页面的理解</h2> <p><code>SPA（ single-page application ）</code>仅在 <code>Web</code> 页面初始化时加载相应的 <code>HTML、CSS</code> 和 <code>JavaScript</code>。一旦页面加载完成，<code>SPA</code> 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 <code>HTML</code> 内容的变换，<code>UI</code> 与用户的交互，避免页面的重新加载。</p> <p><strong>优点</strong></p> <ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，<code>SPA</code> 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul> <p><strong>缺点</strong></p> <ul><li>初次加载耗时多：为实现单页 <code>Web</code> 应用功能及显示效果，需要在加载页面的时候将 <code>JavaScript</code>、<code>CSS</code> 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；（通过资料查阅，其实是前端路由机制解决了单页应用无法前进后退的问题。<code>Hash</code> 模式中Hash变化会被浏览器记录（<code>onhashchange</code> 事件），<code>History</code> 模式利用 <code>H5</code> 新增的 <code>pushState</code> 和 <code>replaceState</code> 方法可改变浏览器历史记录栈。）</li> <li><code>SEO</code> 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 <code>SEO</code> 上其有着天然的弱势。</li></ul> <h2 id="_8、computed-和-watch-的区别？"><a href="#_8、computed-和-watch-的区别？" class="header-anchor">#</a> 8、computed 和 watch 的区别？</h2> <p><strong>区别</strong></p> <ul><li><code>computed</code>： 是计算属性，依赖其它属性值，并且 <code>computed</code> 的值有缓存，只有它依赖的属性值发生改变，才会重新计算 <code>computed</code> 的值；</li> <li><code>watch</code>： 更多的是「观察」的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作；</li></ul> <p><strong>运用场景</strong></p> <ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 <code>computed</code>，因为可以利用 <code>computed</code> 的缓存特性，避免每次获取值时，都要重新计算。</li> <li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 <code>watch</code>，因为使用 <code>watch</code> 选项允许我们执行异步操作 ( 访问一个 <code>API</code> )，限制我们执行该操作的频率，这些都是计算属性无法做到的。</li></ul> <p><strong>computed 的原理?</strong><br> <code>computed</code> 本质是一个惰性求值的观察者。当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 <code>lazy</code>（懒计算）特性。</p> <h2 id="_9、vue-组件-data-为什么必须是函数"><a href="#_9、vue-组件-data-为什么必须是函数" class="header-anchor">#</a> 9、Vue 组件 data 为什么必须是函数?</h2> <p>因为组件是可以复用的,<code>JS</code> 对象是引用关系,如果组件 <code>data</code> 是一个对象,那么子组件中的 <code>data</code> 属性值会互相污染, 产生副作用。 所以一个组件的 <code>data</code> 选项必须是一个函数。</p> <h2 id="_10、谈谈-keep-alive-的理解？"><a href="#_10、谈谈-keep-alive-的理解？" class="header-anchor">#</a> 10、谈谈 keep-alive 的理解？</h2> <p><strong>keep-alive</strong> 是 <strong>Vue</strong> 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p> <ul><li>一般结合路由和动态组件一起使用，用于缓存组件。</li> <li>提供 <code>include</code> 和 <code>exclude</code> 属性，两者都支持字符串或正则表达式， <code>include</code> 表示只有名称匹配的组件会被缓存，<code>exclude</code> 表示任何名称匹配的组件都不会被缓存 ，其中 <code>exclude</code> 的优先级比 <code>include</code> 高。</li> <li>对应两个钩子函数 <code>activated</code> 和 <code>deactivated</code>，当组件被激活时，触发钩子函数 <code>activated</code>，当组件被移除时，触发钩子函数 <code>deactivated</code>。</li></ul> <h2 id="_11、vue-中的-key-有什么作用？"><a href="#_11、vue-中的-key-有什么作用？" class="header-anchor">#</a> 11、Vue 中的 key 有什么作用？</h2> <p><strong>作用：</strong> <code>key</code> 是为 <code>Vue</code> 中 vnode 的唯一标记，通过这个 <code>key</code>，我们的 <code>diff</code> 操作可以更准确、更快速。<br> <strong>更准确：</strong> 因为带 <code>key</code> 就不是就地复用了，在 <code>sameNode</code> 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。<br> <strong>更快速：</strong> 因为利用 <code>key</code> 的唯一性生成 <code>Map</code> 对象来获取对应节点，比遍历方式更快</p> <h2 id="_12、vue-组件通信方式"><a href="#_12、vue-组件通信方式" class="header-anchor">#</a> 12、Vue 组件通信方式</h2> <ul><li><code>props / $emit</code>，适用父子组件之间的通信</li> <li><code>$parent / $children</code>， 适用父子组件之间的通信</li> <li><code>ref / $refs</code>， 适用父子组件之间的通信</li> <li><code>.sync / $emit('update:foo', newValue)</code></li> <li><code>$attrs / $listeners</code> 适用于隔代组件之间的通信</li> <li><code>provide / inject</code> 适用于隔代组件通信</li> <li><code>EventBus</code></li> <li><code>vuex</code> 适用于父子、隔代、兄弟组件通信</li></ul> <h2 id="_13、请介绍一下你对-vuex-的理解？"><a href="#_13、请介绍一下你对-vuex-的理解？" class="header-anchor">#</a> 13、请介绍一下你对 Vuex 的理解？</h2> <p><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。它用于存储所有组件的状态，其核心就是 <code>store</code>（仓库）。<code>&quot;store&quot;</code> 基本上就是一个容器，它包含着你的应用中大部分的状态 ( <code>state</code> )。</p> <h3 id="_1、响应式"><a href="#_1、响应式" class="header-anchor">#</a> 1、响应式</h3> <ul><li><code>Vuex</code> 的状态存储是响应式的。当 Vue 组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li> <li>改变 <code>store</code> 中的状态的唯一途径就是显式地提交 <code>(commit)mutation</code>。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul> <h3 id="_2、模块"><a href="#_2、模块" class="header-anchor">#</a> 2、模块</h3> <p>主要包括以下几个模块：</p> <ul><li><ol><li><code>State</code>：可以设置一些默认的状态。</li></ol></li> <li><ol start="2"><li><code>Getter</code>：类似计算属性，可以获取 <code>Store</code> 中 <code>state</code> 数据来进行二次封装，<code>mapGetters</code> 辅助函数仅仅是将 <code>store</code> 中的 <code>getter</code> 映射到局部计算属性。</li></ol></li> <li><ol start="3"><li><code>Mutation</code>：是唯一更改 <code>store</code> 中状态的方法，且必须是同步函数。</li></ol></li> <li><ol start="4"><li><code>Action</code>：用于提交 <code>mutation</code>，而不是直接变更状态，可以包含任意异步操作。</li></ol></li> <li><ol start="5"><li><code>Module</code>：允许将单一的 <code>Store</code> 拆分为多个 <code>store</code> 且同时保存在单一的状态树中。</li></ol></li></ul> <h3 id="_3、vuex-解决了什么问题？"><a href="#_3、vuex-解决了什么问题？" class="header-anchor">#</a> 3、Vuex 解决了什么问题？</h3> <ul><li>多个组件依赖于同一状态时，对于多层嵌套的组件的状态传递将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。</li> <li>来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</li></ul> <h2 id="_14、说说对-vue-router-的理解？"><a href="#_14、说说对-vue-router-的理解？" class="header-anchor">#</a> 14、说说对 vue-router 的理解？</h2> <p><code>vue-router</code> 有 <code>3</code> 种路由模式：<code>hash、history、abstract</code></p> <ul><li><code>hash</code>: 使用 <code>URL hash</code> 值来作路由。支持所有浏览器，包括不支持 <code>HTML5 History Api</code> 的浏览器；</li> <li><code>history</code>: 依赖 <code>HTML5 History API</code> 和服务器配置。具体可以查看 <code>HTML5 History</code> 模式；</li> <li><code>abstract</code>: 支持所有 <code>JavaScript</code> 运行环境，如 <code>Node.js</code> 服务器端。如果发现没有浏览器的 <code>API</code>，路由会自动强制进入这个模式.</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">'history'</span><span class="token operator">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'hash'</span><span class="token operator">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'abstract'</span><span class="token operator">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="_1、hash-模式的实现原理"><a href="#_1、hash-模式的实现原理" class="header-anchor">#</a> 1、hash 模式的实现原理</h3> <p>在路由中带有一个 <code>#</code>，主要原理是通过监听 <code>#</code> 后的 <code>URL</code> 路径标识符的改变而触发浏览器 <code>hashchange</code> 事件，然后通过获取 <code>location.hash</code> 得到当前的路径标识符，从而对页面进行跳转</p> <p><strong>hash 路由模式的实现主要是基于下面几个特性：</strong></p> <ol><li><code>URL</code> 中 <code>hash</code> 值只是客户端的一种状态，也就是说当向服务器端发出请求时，<code>hash</code> 部分不会被发送；</li> <li><code>hash</code> 值的改变，都会在浏览器访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制 <code>hash</code> 的切换；</li> <li>可以通过 <code>a</code> 标签，并设置 <code>href</code> 属性，当用户点击这个标签后，<code>URL</code> 的 <code>hash</code> 值会发生改变；或者使用 <code>JavaScript</code> 来对 <code>loaction.hash</code> 进行赋值，改变 <code>URL</code> 的 <code>hash</code> 值；</li> <li>我们可以使用 <code>hashchange</code> 事件来监听 <code>hash</code> 值的变化，从而对页面进行跳转（渲染）。
:::</li></ol> <h3 id="_2、history-模式的实现原理"><a href="#_2、history-模式的实现原理" class="header-anchor">#</a> 2、history 模式的实现原理</h3> <p><code>HTML5</code> 提供了<code>History API</code> 来实现 <code>URL</code> 的变化。其中做最主要的 <code>API</code> 有以下两个：<code>history.pushState()</code> 和 <code>history.repalceState()</code>。这两个 <code>API</code> 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p> <ol><li>window.history.pushState(null, null, path);</li> <li>window.history.replaceState(null, null, path);</li></ol> <p><strong>history 路由模式的实现主要基于存在下面几个特性：</strong></p> <ol><li><code>pushState</code> 和 <code>repalceState</code> 两个 <code>API</code> 来操作实现 <code>URL</code> 的变化；</li> <li>我们可以使用 <code>popstate</code> 事件来监听 <code>url</code> 的变化，从而对页面进行跳转（渲染）；</li> <li>调用 <code>history.pushState()</code> 或 <code>history.replaceState()</code> 不会触发 <code>popstate</code> 事件，这时我们需要手动触发页面跳转（渲染）。
:::</li></ol> <h2 id="_15、vue-router-有哪几种导航守卫"><a href="#_15、vue-router-有哪几种导航守卫" class="header-anchor">#</a> 15、vue-router 有哪几种导航守卫?</h2> <ul><li>全局守卫</li> <li>路由独享守卫</li> <li>路由组件内的守卫</li></ul> <h3 id="_1、全局守卫"><a href="#_1、全局守卫" class="header-anchor">#</a> 1、全局守卫</h3> <p><code>vue-router</code> 全局有三个守卫：</p> <ul><li><code>router.beforeEach</code> 全局前置守卫 进入路由之前</li> <li><code>router.beforeResolve</code> 全局解析守卫(2.5.0+) 在 <code>beforeRouteEnter</code> 调用之后调用</li> <li><code>router.afterEach</code> 全局后置钩子 进入路由之后</li></ul> <p>使用方法:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// main.js 入口文件</span>
  <span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token punctuation">;</span> <span class="token comment">// 引入路由</span>
  router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'afterEach 全局后置钩子'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_2、路由独享守卫"><a href="#_2、路由独享守卫" class="header-anchor">#</a> 2、路由独享守卫</h3> <p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token operator">:</span> <span class="token string">'/foo'</span><span class="token punctuation">,</span>
      component<span class="token operator">:</span> Foo<span class="token punctuation">,</span>
      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
        <span class="token comment">// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span>
        <span class="token comment">// ...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_3、路由组件内的守卫"><a href="#_3、路由组件内的守卫" class="header-anchor">#</a> 3、路由组件内的守卫</h3> <ul><li><code>beforeRouteEnter</code> 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 <code>this</code>，组件实例还没被创建</li> <li><code>beforeRouteUpdate</code> (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 <code>this</code></li> <li><code>beforeRouteLeave</code> 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 <code>this</code></li></ul> <h2 id="_16、nexttick实现原理"><a href="#_16、nexttick实现原理" class="header-anchor">#</a> 16、nextTick实现原理?</h2> <p><strong>(宏任务和微任务) 异步方法</strong><br> <code>nextTick</code> 方法主要是使用了宏任务和微任务，定义了一个异步方法。多次调用 <code>nextTick</code> 会将方法存入 队列中，通过这个异步方法清空当前队列。 所以这个 <code>nextTick</code> 方法就是异步方法</p> <h2 id="_17、vue-的双向数据绑定原理"><a href="#_17、vue-的双向数据绑定原理" class="header-anchor">#</a> 17、Vue 的双向数据绑定原理?</h2> <p>响应式原理就是，我们通过递归遍历，把vue实例中 <code>data</code> 里面定义的数据，用 <code>defineReactive（Object.defineProperty）</code> 重新定义。每个数据内新建一个 <code>Dep</code> 实例，闭包中包含了这个 <code>Dep</code> 类的实例，用来收集 <code>Watcher</code> 对象。在对象被「读」的时候，会触发 <code>reactiveGetter</code> 函数把当前的 <code>Watcher</code> 对象（存放在 <code>Dep.target</code> 中）收集到 <code>Dep</code> 类中去。之后如果当该对象被「写」的时候，则会触发 <code>reactiveSetter</code> 方法，通知 <code>Dep</code> 类调用 <code>notify</code> 来触发所有 <code>Watcher</code> 对象的 <code>update</code> 方法更新对应视图。</p> <p><code>Vue</code> 响应式原理的核心就是 <code>Observer、Dep、Watcher</code> 三个类。<br> <code>Observer</code> 中进行响应式的绑定，在数据被读的时候，触发get方法，执行 <code>Dep</code> 来收集依赖，也就是收集 <code>Watcher</code>。
在数据被改的时候，触发 <code>set</code> 方法，通过对应的所有依赖(<code>Watcher</code>)，去执行更新。比如 <code>watch</code> 和 <code>computed</code> 就执行开发者自定义的回调方法。</p> <p><code>vue.js</code> 是采用数据劫持和发布者-订阅者模式的方式， 通过 <code>Object.defineProperty</code> 创建⼀个 <code>observe</code> 来劫持监听所有的属性，把这些属性全部转为 <code>getter</code>
和 <code>setter</code> 。<code>Vue</code> 中每个组件实例都会对应⼀个 <code>watcher</code> 实例，它会在组件渲染的过程中把使⽤过的数据属性通过 <code>getter</code> 收集为依赖。之后当依赖项的 <code>setter</code> 触发时，会通知 <code>watcher</code> ，从⽽使它关联的组件重新渲染。</p> <p>主要分为以下几个步骤：</p> <div class="tip custom-block"><p class="custom-block-title">步骤 1</p> <p>1、需要 <code>Observer</code> 的数据对象进行递归遍历，包括子属性对象的属性，都加上 <code>setter/getter</code>，这样的话，给这个对象的某个值赋值，就会触发 <code>setter</code>，那么就能够监听到数据的变化</p></div> <div class="tip custom-block"><p class="custom-block-title">步骤 2</p> <p>2、<code>compile</code> 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据发生变化，收到通知，更新视图</p></div> <div class="tip custom-block"><p class="custom-block-title">步骤 3</p> <p>3、<code>Watcher</code> 订阅者是 <code>Observer</code> 和 <code>Compile</code> 之间通信的桥梁，主要做的事情是:<br>
①在自身实例化时往属性订阅器(<code>dep</code>)里添加自己。<br>
②自身必须有一个 <code>update()</code> 方法。<br>
③待属性变动 <code>dep.notify()</code> 通知时，能调用自身的 <code>update()</code> 方法，并触发 <code>Compile</code> 中绑定的回调，更新视图。</p></div> <div class="tip custom-block"><p class="custom-block-title">步骤4</p> <p>4、<code>MVVM</code> 作为数据绑定的入口，整合 <code>Observer</code>、<code>Compile</code> 和 <code>Watcher</code> 三者，通过 <code>Observer</code> 来监听自己的数据变化，通过 <code>Compile</code> 来解析模板指令，最终利用 <code>Watcher</code> 搭起 <code>Observer</code> 和 <code>Compile</code> 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(<code>input</code>) -&gt; 数据更新的双向绑定效果。</p></div> <h2 id="_18、怎样理解-vue-的单向数据流？"><a href="#_18、怎样理解-vue-的单向数据流？" class="header-anchor">#</a> 18、怎样理解 Vue 的单向数据流？</h2> <p><code>vue</code> 组件间传递数据是单向的，即数据总是由父组件传递到子组件，子组件在其内部可以有自己维护的数据，但它无权修改父组件传递给它的数据，当我们尝试这样做的时候，<code>vue</code> 将会报错。这样做是为了组件间更好的解耦，在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以 <code>vue</code> 不推荐子组件修改父组件的数据，直接修改 <code>props</code> 会抛出警告。</p> <p>所以，当你想要在子组件去修改 <code>props</code> 时，把这个子组件当成父组件那样用，所以就有了</p> <ul><li>1、定义一个局部变量，并用 <code>prop</code> 的值初始化它。</li> <li>2、定义一个计算属性，处理 <code>prop</code> 的值并返回。</li></ul> <h2 id="_19、v-model-的原理？"><a href="#_19、v-model-的原理？" class="header-anchor">#</a> 19、v-model 的原理？</h2> <p><code>v-model</code> 指令用于实现 <code>input</code>、<code>select</code> 等表单元素的双向绑定，是个语法糖。<br>
我们在 <code>vue</code> 项目中主要使用 <code>v-model</code> 指令在表单 <code>input</code>、<code>textarea</code>、<code>select</code> 等元素上创建双向数据绑定，我们知道 <code>v-model</code> 本质上不过是语法糖，<code>v-model</code> 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <ol><li><code>text</code> 和 <code>textarea</code> 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li> <li><code>checkbox</code> 和 <code>radio</code> 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li> <li><code>select</code> 字段将 <code>value</code> 作为 <code>prop</code> 并将 <code>change</code> 作为事件。</li></ol> <p><strong>以 input 表单元素为例：</strong></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>something<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 相当于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果在自定义组件中，<code>v-model</code> 默认会利用名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件，如下所示：</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- 父组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base-checkbox</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>baseCheck<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 子组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>checkbox<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>checked<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$emit(<span class="token punctuation">'</span>change<span class="token punctuation">'</span>, $event.target.checked)<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  model<span class="token operator">:</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token string">'checked'</span><span class="token punctuation">,</span>
    event<span class="token operator">:</span> <span class="token string">'change'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    checked<span class="token operator">:</span> Boolean
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="_20、-vue中是如何检测数组变化"><a href="#_20、-vue中是如何检测数组变化" class="header-anchor">#</a> 20、 Vue中是如何检测数组变化?</h2> <ul><li>使用函数劫持的方式，重写了数组的方法</li> <li><code>Vue</code> 将 <code>data</code> 中的数组，进行了原型链重写。指向了自己定义的数组原型方法，这样当调用数组 <code>api</code> 时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控。</li></ul> <h2 id="_21、proxy-与-defineproperty-对比"><a href="#_21、proxy-与-defineproperty-对比" class="header-anchor">#</a> 21、Proxy 与 defineProperty 对比</h2> <p><code>Object.defineProperty</code> 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。<code>Vue 2.x</code> 里,是通过 递归遍历 <code>data</code> 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。</p> <p><code>Proxy</code> 可以劫持整个对象,并返回一个新的对象。<code>Proxy</code> 不仅可以代理对象,还可以代理数组。还可以代理动态增加新的属性。</p> <p><strong>Proxy 的优势如下</strong></p> <ul><li><code>Proxy</code> 可以直接监听对象而非属性；</li> <li><code>Proxy</code> 可以直接监听数组的变化；</li> <li><code>Proxy</code> 有多达 <code>13</code> 种拦截方法,不限于 <code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code> 等等是 <code>Object.defineProperty</code> 不具备的；</li> <li><code>Proxy</code> 返回的是一个新对象,我们可以只操作新的对象达到目的,而 <code>Object.defineProperty</code> 只能遍历对象属性直接修改；</li> <li><code>Proxy</code> 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul> <p><strong>Object.defineProperty 的优势如下</strong></p> <ul><li>兼容性好，支持 <code>IE9</code>，而 <code>Proxy</code> 的存在浏览器兼容性问题,而且无法用 <code>polyfill</code> 磨平，因此 <code>Vue</code> 的作者才声明需要等到下个大版本( <code>3.0</code> )才能用 <code>Proxy</code> 重写。</li></ul> <h2 id="_22、vm-set-解决对象响应式"><a href="#_22、vm-set-解决对象响应式" class="header-anchor">#</a> 22、vm.$set() 解决对象响应式?</h2> <p>受现代 <code>JavaScript</code> 的限制 ，<code>Vue</code> 无法检测到对象属性的添加或删除。由于 <code>Vue</code> 会在初始化实例时对属性执行 <code>getter/setter</code> 转化，所以属性必须在 <code>data</code> 对象上存在才能让 <code>Vue</code> 将它转换为响应式的。但是 <code>Vue</code> 提供了 <code>Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</code> 来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p> <p>我们查看对应的 <code>Vue</code> 源码：<code>vue/src/core/instance/index.js</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">set</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> any<span class="token punctuation">,</span> val<span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// target 为数组  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的splice变异方法触发响应式  </span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// key 已经存在，直接修改属性值  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// target 本身就不是响应式数据, 直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 对属性进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>vm.$set 的实现原理</strong></p> <ul><li>如果目标是数组，直接使用数组的 <code>splice</code> 方法触发响应式；</li> <li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 <code>defineReactive</code> 方法进行响应式处理（<code>defineReactive</code> 方法就是 <code>Vue</code> 在初始化对象时，给对象属性采用 <code>Object.defineProperty</code> 动态添加 <code>getter</code> 和 <code>setter</code> 的功能所调用的方法）</li></ul> <h2 id="_23、虚拟-dom-概念及实现原理？"><a href="#_23、虚拟-dom-概念及实现原理？" class="header-anchor">#</a> 23、虚拟 DOM 概念及实现原理？</h2> <h3 id="_1、什么是虚拟-dom"><a href="#_1、什么是虚拟-dom" class="header-anchor">#</a> 1、什么是虚拟 DOM</h3> <p><code>Virtual DOM</code>(虚拟 <code>DOM</code>)，是由普通的 <code>JS</code> 对象来描述 <code>DOM</code> 对象，因为不是真实的 <code>DOM</code> 对象，所以叫 <code>Virtual DOM</code>。</p> <h3 id="_2、为什么要使用虚拟-dom？"><a href="#_2、为什么要使用虚拟-dom？" class="header-anchor">#</a> 2、为什么要使用虚拟 DOM？</h3> <p>真实 <code>DOM</code> 成员非常的多，对于一个简单的 <code>div</code> 打印的真实的 <code>DOM</code> 节点的成员非常多，而对于虚拟 <code>DOM</code> 节点只是用简单的 <code>JS</code> 对象表示，极大的节省资源。<br>
因此创建一个虚拟 <code>DOM</code> 的成本比创建一个真实 <code>DOM</code> 的成本小很多，因此可以极大的节省成本。</p> <ul><li>手动操作 <code>DOM</code> 比较麻烦，还需要考虑浏览器兼容问题，虽然 <code>jQuery</code> 等库简化 <code>DOM</code> 操作，但是随着项目的复杂 <code>DOM</code> 操作复杂提升</li> <li>为了简化 <code>DOM</code> 的复杂操作于是出现了各种 <code>MVVM</code> 框架，<code>MVVM</code> 框架解决了视图和状态的同步问题</li> <li><code>Virtual DOM</code> 的好处是当前状态改变时不需要立即更新 <code>DOM</code>，只需要创建一个虚拟树来描述 <code>DOM</code>，<code>Virtual DOM</code> 内部将弄清楚是如何有效(<code>diff</code>)的更新 <code>DOM</code></li> <li>参考 <code>github</code> 上 <code>virtual-dom</code> 的描述
<ul><li>虚拟 <code>DOM</code> 可以维护程序的状态，跟踪上一次的状态</li> <li>通过比较前后两次状态的差异更新真实 <code>DOM</code></li></ul></li></ul> <h3 id="_3、虚拟-dom-的作用"><a href="#_3、虚拟-dom-的作用" class="header-anchor">#</a> 3、虚拟 DOM 的作用</h3> <ul><li>维护视图和状态的关系</li> <li>复杂视图情况下提升渲染性能</li> <li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>，原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)</li> <li>真实 <code>DOM</code> 的属性很多，创建 <code>DOM</code> 节点开销很大; 虚拟 <code>DOM</code> 是由普通的 <code>JS</code> 对象来描述 <code>DOM</code> 对象，描述属性并不需要很多，创建开销很小</li></ul> <p><strong>灵魂发问:使用了虚拟DOM就一定会比直接渲染真实DOM快吗?</strong></p> <p>举例:当一个节点变更时 <code>DOMA-&gt;DOMB</code></p> <p><img src="/assets/img/1.1e5a598c.png" alt></p> <p>答：示例 <code>1</code> 是创建一个 <code>DOMB</code> 然后替换掉 <code>DOMA</code>; 示例 <code>2</code> 去创建虚拟 <code>DOM+DIFF</code> 算法比对发现 <code>DOMB</code> 跟 <code>DOMA</code> 不是相同的节点,最后还是创建一个 <code>DOMB</code> 然后替换掉 <code>DOMA</code>; 可以明显看出 <code>1</code> 是更快的,同样的结果, <code>2</code> 还要去创建虚拟 <code>DOM+DIFF</code> 算啊对比 所以说使用虚拟DOM比直接操作真实 <code>DOM</code> 就一定要快这个说法是错误的,不严谨的。</p> <p>举例:当 <code>DOM</code> 树里面的某个子节点的内容变更时:</p> <p><img src="/assets/img/2.1b85cfb6.png" alt></p> <p>当一些复杂的节点,比如说一个父节点里面有多个子节点,当只是一个子节点的内容发生了改变,那么我们没有必要像示例1重新去渲染这个 <code>DOM</code> 树,这个时候虚拟 <code>DOM+DIFF</code> 算法就能够得到很好的体现,我们通过示例 <code>2</code> 使用虚拟 <code>DOM+Diff</code> 算法去找出改变了的子节点更新它的内容就可以了</p> <p><strong>总结:</strong><br>
复杂视图情况下提升渲染性能,因为虚拟 <code>DOM+Diff</code> 算法可以精准找到 <code>DOM</code> 树变更的地方,减少 <code>DOM</code> 的操作(重排重绘)</p> <p><strong>Virtual DOM 库：</strong></p> <ul><li><code>Snabbdom</code> <ul><li><code>Vue 2.x</code> 内部使用的<code>Virtual DOM</code> 就是改造的 <code>Snabbdom</code></li> <li>大约 <code>200 SLOC (single line of code)</code></li> <li>通过模块可扩展</li> <li>源码使用 <code>TypeScript</code> 开发</li> <li>最快的 <code>Virtual DOM</code> 之一</li></ul></li> <li><code>virtual-dom</code></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>
<span class="token comment">// 真实 DOM</span>
<span class="token keyword">let</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">''</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s <span class="token operator">+=</span> key<span class="token punctuation">,</span> <span class="token string">','</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token comment">// 非常多属性</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 虚拟 DOM</span>
<span class="token punctuation">{</span>
    sel<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span> 
    data<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    text<span class="token operator">:</span> <span class="token string">'Hello Virtual DOM'</span><span class="token punctuation">,</span>
    elm<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    key<span class="token operator">:</span> <span class="token keyword">undefined</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="tip custom-block"><p class="custom-block-title">虚拟 `DOM` 的实现原理主要包括以下 `3` 部分：</p> <ol><li>用 <code>JavaScript</code> 对象模拟真实 <code>DOM</code> 树，对真实 <code>DOM</code> 进行抽象；</li> <li><code>diff</code> 算法 — 比较两棵虚拟 <code>DOM</code> 树的差异；</li> <li><code>pach</code> 算法 — 将两个虚拟 <code>DOM</code> 对象的差异应用到真正的 <code>DOM</code> 树。</li></ol></div> <h3 id="_4、diff-算法"><a href="#_4、diff-算法" class="header-anchor">#</a> 4、diff 算法</h3> <ul><li>把新节点中变化的内容渲染到真实 <code>DOM</code>,最后返回新节点作为下一次处理的旧节点(核心)</li> <li>当组件创建和更新时，<code>vue</code> 会执行内部的 <code>update</code> 函数，该函数使用 <code>render</code> 函数生成的虚拟 <code>dom</code> 树，将新旧两树进行对比，找到差异点，最终更新到真实 <code>dom</code></li> <li>对比差异的过程叫 <code>diff</code> 算法</li> <li>在对比时，<code>vue</code> 采用 <strong>深度优先、同级比较</strong> 的方式进行比对。同级比较就是说它不会跨越结构进行比较</li> <li>首先，在判断两个节点是否相同时，<code>vue</code> 是通过虚拟节点的 <code>key</code> 和 <code>sel</code> 来进行判断的</li> <li>如果不是相同节点，删除之前的内容，重新渲染</li> <li>如果是相同节点，再判断 <code>VNode</code> 是否有 <code>text</code>，并且和 <code>oldVnode</code> 的 <code>text</code> 不同时，直接更新文本内容</li> <li>如果新的 <code>VNode</code> 有 <code>children</code>,判断子节点是否有变化( <code>updateChildren</code>,最麻烦,最难实现)，有以下三种情况：
<ul><li>只有新节点有 <code>children</code>，则添加所有的子节点</li> <li>只有老节点有 <code>children</code>，移除所有的老节点</li> <li>新老节点都有 <code>children</code> 且不相等，则需要对比子节点并且更新子节点的差异，有以下五种情况：
<ul><li><code>oldStartVnode/newStartVnode</code> (旧开始节点/新开始节点)相同
<ul><li>首先判断是否相同节点,找出两者之间的差异,结束一次循环，并进行相应的移位 <code>oldStartIdx++/newStartIdx++</code></li></ul></li> <li><code>oldEndVnode/newEndVnode</code> (旧结束节点/新结束节点)相同
<ul><li>首先判断是否相同节点)，找出两者之间的差异,结束一次循环，并进行相应的移位 <code>oldEndIdx--/newEndIdx--</code></li></ul></li> <li><code>oldStartVnode/newEndVnode</code> (旧开始节点/新结束节点)相同
<ul><li>判断是否相同节点，找出两者之间的差异,将 <code>oldCh[oldStartIdx]</code> 对应的真实 <code>dom</code> 位移到 <code>oldCh[oldEndIdx]</code> 对应的真实 <code>dom</code> 后，并进行相应的移位 <code>oldStartIdx++/newEndIdx--</code>;</li></ul></li> <li><code>oldEndVnode/newStartVnode</code> (旧结束节点/新开始节点)相同
<ul><li>判断是否相同节点,找出两者之间的差异,将 <code>oldCh[oldEndIdx]</code> 对应的真实 <code>dom</code> 位移到 <code>oldCh[oldStartIdx]</code> 对应的真实 <code>dom</code> 前, 并进行相应的移位 <code>oldEndIdx--/newStartIdx++</code>;</li></ul></li> <li>特殊情况当 <code>1,2,3,4</code>的情况都不符合，则在 <code>oldVnodes</code> 里面寻找跟 <code>newStartVnode</code> 一样的节点然后位移到 <code>oldCh[oldStartIdx]</code> 对应的真实 <code>dom</code> 前,若没有找到，则则创建一个与 <code>newCh[newStartIdx]</code> 节点对应的真实 <code>dom</code> 插入到 <code>oldCh[oldStartIdx]</code> 对应的真实 <code>dom</code> 前, 并进行相应的移位 <code>newStartIdx++</code></li></ul></li></ul></li> <li>结束循环的收尾工作(<code>oldStartIdx&gt;oldEndIdx</code> || <code>newStartIdx&gt;newEndIdx</code>)
<ul><li>新节点的所有子节点先遍历完(<code>newStartIdx&gt;newEndIdx</code>),循环结束</li> <li>新节点的所有子节点遍历结束就是把没有对应相同节点的子节点删除</li> <li>旧节点的所有子节点先遍历完(<code>oldStartIdx&gt;oldEndIdx</code>),循环结束</li> <li>旧节点的所有子节点遍历结束就是在多出来的子节点插入到旧节点结束节点前;(源码:<code>newCh[newEndIdx + 1].elm</code>),就是对应的旧结束节点的真实 <code>dom</code>,<code>newEndIdx+1</code>是因为在匹配到相同的节点需要 <code>-1</code> ,所以需要加回来就是结束节点</li></ul></li> <li>在对比其子节点数组时，<code>vue</code> 对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实 <code>dom</code>，尽量少的销毁和创建真实 <code>dom</code>。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实 <code>dom</code> 到合适的位置。</li> <li>这样一直递归的遍历下去，直到整棵树完成对比</li></ul> <h2 id="_24、vue-项目优化？"><a href="#_24、vue-项目优化？" class="header-anchor">#</a> 24、Vue 项目优化？</h2> <h3 id="_1、代码层面的优化"><a href="#_1、代码层面的优化" class="header-anchor">#</a> 1、代码层面的优化</h3> <ul><li><ol><li><code>v-if</code> 和 <code>v-show</code> 区分使用场景</li></ol></li> <li><ol start="2"><li><code>computed</code> 和 <code>watch</code>  区分使用场景</li></ol></li> <li><ol start="3"><li><code>v-for</code> 遍历必须为每个 <code>item</code> 添加 <code>key</code>，且避免同时使用 <code>v-if</code></li></ol></li> <li><ol start="4"><li>长列表性能优化</li></ol></li> <li><ol start="5"><li>事件的销毁</li></ol></li> <li><ol start="6"><li>图片懒加载</li></ol></li> <li><ol start="7"><li>路由懒加载</li></ol></li> <li><ol start="8"><li>第三方插件的按需引入</li></ol></li> <li><ol start="9"><li>优化无限列表性能</li></ol></li> <li><ol start="10"><li>服务端渲染 <code>SSR</code> 或者预渲染</li></ol></li></ul> <h3 id="_2、webpack-层面的优化"><a href="#_2、webpack-层面的优化" class="header-anchor">#</a> 2、Webpack 层面的优化</h3> <ul><li><ol><li><code>Webpack</code> 对图片进行压缩</li></ol></li> <li><ol start="2"><li>减少 <code>ES6</code> 转为 <code>ES5</code> 的冗余代码</li></ol></li> <li><ol start="3"><li>提取公共代码</li></ol></li> <li><ol start="4"><li>模板预编译</li></ol></li> <li><ol start="5"><li>提取组件的 <code>CSS</code></li></ol></li> <li><ol start="6"><li>优化 <code>SourceMap</code></li></ol></li> <li><ol start="7"><li>构建结果输出分析</li></ol></li> <li><ol start="8"><li><code>Vue</code> 项目的编译优化</li></ol></li></ul> <h3 id="_3、基础的-web-技术的优化"><a href="#_3、基础的-web-技术的优化" class="header-anchor">#</a> 3、基础的 Web 技术的优化</h3> <ul><li><ol><li>开启 <code>gzip</code> 压缩</li></ol></li> <li><ol start="2"><li>浏览器缓存</li></ol></li> <li><ol start="3"><li><code>CDN</code> 的使用</li></ol></li> <li><ol start="4"><li>使用 <code>Chrome Performance</code> 查找性能瓶颈</li></ol></li></ul> <h2 id="_25、vue3-0-特性的了解？"><a href="#_25、vue3-0-特性的了解？" class="header-anchor">#</a> 25、vue3.0 特性的了解？</h2> <p><code>Vue 3.0</code> 的目标是让 <code>Vue</code> 核心变得更小、更快、更强大，因此 <code>Vue 3.0</code> 增加以下这些新特性：</p> <h3 id="_1、监测机制的改变"><a href="#_1、监测机制的改变" class="header-anchor">#</a> 1、监测机制的改变</h3> <p><code>Vue3.0</code> 将带来基于代理 <code>Proxy</code> 的 <code>observer</code> 实现，提供全语言覆盖的反应性跟踪。这消除了 <code>Vue2.0</code>当中基于 <code>Object.defineProperty</code> 的实现所存在的很多限制：</p> <ol><li>只能监测属性，不能监测对象</li> <li>检测属性的添加和删除；</li> <li>检测数组索引和长度的变更；</li> <li>支持 <code>Map、Set、WeakMap</code> 和 <code>WeakSet</code>。</li></ol> <h3 id="_2、新的-observer-特性"><a href="#_2、新的-observer-特性" class="header-anchor">#</a> 2、新的 observer 特性</h3> <ol><li>用于创建 <code>observable</code> 的公开 <code>API</code>。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li> <li>默认采用惰性观察。在 <code>2.x</code> 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 <code>3.x</code> 中，只观察用于渲染应用程序最初可见部分的数据。</li> <li>更精确的变更通知。在 <code>2.x</code> 中，通过 <code>Vue.set</code> 强制添加新属性将导致依赖于该对象的 <code>watcher</code> 收到变更通知。在 <code>3.x</code> 中，只有依赖于特定属性的 <code>watcher</code> 才会收到通知。</li> <li>不可变的 <code>observable</code>：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 <code>prop</code> 传递或 <code>Vuex</code> 状态树以外的变化。</li> <li>更好的调试功能：我们可以使用新的 <code>renderTracked</code> 和 <code>renderTriggered</code> 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ol> <h3 id="_3、模板"><a href="#_3、模板" class="header-anchor">#</a> 3、模板</h3> <p>模板方面没有大的变更，只改了作用域插槽，<code>2.x</code> 的机制导致作用域插槽变了，父组件会重新渲染，而 <code>3.0</code> 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。
同时，对于 <code>render</code> 函数的方面，<code>vue3.0</code> 也会进行一系列更改来方便习惯直接使用 <code>api</code> 来生成 <code>vdom</code>。</p> <h2 id="_26、vue3-0-比起-vue2-x-的优势？"><a href="#_26、vue3-0-比起-vue2-x-的优势？" class="header-anchor">#</a> 26、Vue3.0 比起 Vue2.x 的优势？</h2> <h3 id="_1、性能比2-x快1-2～2倍"><a href="#_1、性能比2-x快1-2～2倍" class="header-anchor">#</a> 1、性能比2.x快1.2～2倍</h3> <h4 id="diff算法的优化"><a href="#diff算法的优化" class="header-anchor">#</a> diff算法的优化</h4> <p>在vue2中，虚拟dom是全量比较的。</p> <p>在vue3中，增加了静态标记PatchFlag。在创建vnode的时候，会根据vnode的内容是否可以变化，为其添加静态标记PatchFlag。diff的时候，只会比较有PatchFlag的节点。PatchFlag是有类型的，比如一个可变化文本节点，会将其添加PatchFlag枚举值为TEXT的静态标记。这样在diff的时候，只需比对文本内容。需要比对的内容更少了。PatchFlag还有动态class、动态style、动态属性、动态key属性等枚举值。</p> <h4 id="render阶段的静态提升（render阶段指生成虚拟dom树的阶段）"><a href="#render阶段的静态提升（render阶段指生成虚拟dom树的阶段）" class="header-anchor">#</a> render阶段的静态提升（render阶段指生成虚拟dom树的阶段）</h4> <p>在vue2中，一旦检查到数据变化，就会re-render组件，所有的vnode都会重新创建一遍，形成新的vdom树。</p> <p>在vue3中，对于不参与更新的vnode，会做静态提升，只会被创建一次，在re-render时直接复用。</p> <p>静态提升可以理解为第一次render不参与更新的vnode节点的时候，保存它们的引用。re-render新vdom树时，直接拿它们的引用过来即可，无需重新创建。</p> <h4 id="事件侦听缓存"><a href="#事件侦听缓存" class="header-anchor">#</a> 事件侦听缓存</h4> <p>在vue2中，我们写的@click=&quot;onClick&quot;也是被当作动态属性，diff的时候也要对比。但我们知道它不会变化，比如变成@click=&quot;onClick2&quot;，绑定别的值。</p> <p>在vue3中，如果事件是不会变化的，会将onClick缓存起来（跟静态提升达到的效果类似），该节点也不会被标记上PatchFlag（也就是无需更新的节点）。这样在render和diff两个阶段，事件侦听属性都节约了不必要的性能消耗。</p> <p>我曾经维护过一个拥有很庞大dom树的页面。由于节点非常多，无需参与更新的节点也很多，使用vue2的情况下，在render和diff两个阶段，消费了很多性能，如果当时有vue3的话，我想性能会被优化很多。</p> <h4 id="减少创建组件实例的开销"><a href="#减少创建组件实例的开销" class="header-anchor">#</a> 减少创建组件实例的开销</h4> <p>vue2.x每创建一个实例，在this上要暴露data、props、computed这些，都是靠Object.defineProperty去定义的。这部分操作还是挺费时的。</p> <p>vue3.0中基于Proxy，减少了创建组件实例的性能开销。</p> <h3 id="_2、按需编译，体积比vue2-x更小（tree-shaking）"><a href="#_2、按需编译，体积比vue2-x更小（tree-shaking）" class="header-anchor">#</a> 2、按需编译，体积比Vue2.x更小（Tree shaking）</h3> <p>在vue3中，可以如下面这样引用vue的功能函数，如果你的项目没有用到watch，那编译时就会把tree shaking掉。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> computed<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> nextTick <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>利用的就是 ES6 模块系统import/export。</p> <h3 id="_3、compostion-api-组合api-注入api"><a href="#_3、compostion-api-组合api-注入api" class="header-anchor">#</a> 3、Compostion API: 组合API/注入API</h3> <p>这里要说到代码的组织方式，传统的网页是html/css/javascript（结构/样式/逻辑）分离。vue/react通过组件化的方式，将联系紧密的结构/样式/逻辑放在一起，有利于代码的维护。</p> <p>compostion api更进一步，着力于JavaScript（逻辑）部分，将逻辑相关的代码放在一起，近而有利于代码的维护。</p> <p>在vue2的组件内，使用的是Option API风格(data/methods/mounted)来组织的代码，这样会让逻辑分散，举个例子就是我们完成一个计数器功能，要在data里声明变量，在methods定义响应函数，在mounted里初始化变量，如果在一个功能比较多、代码量比较大的组件里，你要维护这样一个功能，就需要在data/methods/mounted反复的切换到对应位置，然后进行代码的更改。</p> <p>在vue3中，使用setup函数。如下所示跟count相关的逻辑，都放到counter.js文件里，跟todo相关的逻辑放到todos.js里。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> useCounter <span class="token keyword">from</span> <span class="token string">'./counter'</span>
<span class="token keyword">import</span> useTodo <span class="token keyword">from</span> <span class="token string">'./todos'</span>

<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> val<span class="token punctuation">,</span> todos<span class="token punctuation">,</span> addTodo <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useTodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span>count<span class="token punctuation">,</span>add<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    val<span class="token punctuation">,</span> todos<span class="token punctuation">,</span> addTodo<span class="token punctuation">,</span>
    count<span class="token punctuation">,</span>add<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在我看来这就是Compostion API最大的特点，以功能为单位的代码组织方式。同时它可以让代码更易重用。</p> <p>说到重用，Compostion API的方式也比mixin的方式好很多，你可以清楚的看到组件使用的数据和方法来自哪个模块，而mixin进组件的功能，常常会让我们困惑此功能来自哪个mixin。</p> <h3 id="_4、更好的ts支持"><a href="#_4、更好的ts支持" class="header-anchor">#</a> 4、更好的TS支持</h3> <p>vue2不适合使用ts，原因在于vue2的Option API风格。options是个简单对象，而ts是一种类型系统、面向对象的语法。两者有点不匹配。</p> <p>在vue2结合ts的具体实践中，要用 vue-class-component 强化 vue 组件，让 Script 支持 TypeScript 装饰器，用 vue-property-decorator 来增加更多结合 Vue 特性的装饰器，最终搞的ts的组件写法和js的组件写法差别挺大。</p> <p>在vue3中，量身打造了defineComponent函数，使组件在ts下，更好的利用参数类型推断 。Composition API 代码风格中，比较有代表性的api就是 ref 和 reactive，也很好的支持了类型声明。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineComponent<span class="token punctuation">,</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
 
<span class="token keyword">const</span> Component <span class="token operator">=</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    success<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> String <span class="token punctuation">}</span><span class="token punctuation">,</span>
    student<span class="token operator">:</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> Object <span class="token keyword">as</span> PropType<span class="token operator">&lt;</span>Student<span class="token operator">&gt;</span><span class="token punctuation">,</span>
      required<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> year <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> month <span class="token operator">=</span> ref<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span>
    
    month<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">9</span> <span class="token comment">// OK</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> year<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; Property 'split' does not exist on type 'number'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="_5、自定义渲染api（custom-renderer-api）"><a href="#_5、自定义渲染api（custom-renderer-api）" class="header-anchor">#</a> 5、自定义渲染API（Custom Renderer API）</h3> <h4 id="vue2-x架构问题"><a href="#vue2-x架构问题" class="header-anchor">#</a> vue2.x架构问题</h4> <p>vue2.x最开始支持运行在浏览器中，渲染到浏览器的dom上，随着vue的流行，出现了weex和myvue。</p> <ul><li>weex：移动端跨平台方案，需要渲染到移动设备。weex被写在vue原项目里，缺点是这使vue原项目更大了，也不是通用解决方案。</li> <li>myvue：小程序上使用，需要渲染到小程序框架上。myvue是单独fork一份源代码进行更改，缺点也非常明显，myvue中vue的版本跟官方版本从fork的那一刻开始，就要开始不一致了。</li></ul> <p>vue2.x项目架构对于这种渲染到不同平台不太友好，vue3.0推出了自定义渲染API解决了该问题。</p> <p>下面我们先看vue2和vue3的入口写法有所不同：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// vue2</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>

<span class="token comment">// vue3</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span>  <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">&quot;./src/App&quot;</span>
<span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>vue官方实现的 createApp 会给我们的 template 映射生成 html 代码，但是要是你不想渲染生成到 html ，而是要渲染生成到 canvas 之类的不是html的代码的时候，那就需要用到 Custom Renderer API 来定义自己的 render 渲染生成函数了。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 你自己实现一个createApp，比如是渲染到canvas的。</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./runtime-render&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">&quot;./src/App&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 根组件</span>

<span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>有了Custom Renderer API，如weex和myvue这类方案的问题就得到了完美解决。只需重写createApp即可。</p> <h3 id="_6、更先进的组件"><a href="#_6、更先进的组件" class="header-anchor">#</a> 6、更先进的组件</h3> <h4 id="fragment组件"><a href="#fragment组件" class="header-anchor">#</a> Fragment组件</h4> <p>// vue2是不允许这样写的，组件必须有一个跟节点，现在可以这样写，vue将为我们创建一个虚拟的Fragment节点。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>World<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这样写有何好处呢？一是如果根节点不是必要的，无需创建了，减少了节点数。二是Fragment节点是虚拟的，不会DOM树中呈现。</p> <h4 id="suspense组件"><a href="#suspense组件" class="header-anchor">#</a> Suspense组件</h4> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Suspense</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Suspended-component</span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#fallback</span><span class="token punctuation">&gt;</span></span>
    Loading...
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Suspense</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在Suspended-component完全渲染之前，备用内容会被显示出来。如果是异步组件，Suspense可以等待组件被下载，或者在设置函数中执行一些异步操作。</p> <h3 id="_7、更快的开发体验（vite开发构建工具）"><a href="#_7、更快的开发体验（vite开发构建工具）" class="header-anchor">#</a> 7、更快的开发体验（vite开发构建工具）</h3> <p>在使用webpack作为开发构建工具时，npm run dev都要等一会，项目越大等的时间越长。热重载页有几秒的延迟，但是如果用vite来做vue3的开发构建工具，npm run dev 秒开，热重载也很快。这种开发体验真是很爽，拒绝等待。</p> <p>vite的原理还是用了浏览器支持import关键字了，启动项目不用webpack构建工具先构建了，浏览器直接请求路由对应的代码文件，代理服务器针对单个文件进行编译并返回。如果请求的文件里还import了其他文件，同理浏览器继续发请求，代理服务器返回。就这样实现了npm run dev时无需编译，实时请求实时编译。</p> <p><strong>总结：</strong></p> <p>其他的，数据监听方式变成了Proxy，消除了Object.defineProperty现有的限制（例如无法检测新的属性添加），并提供更好的性能。</p> <p>vue3解决了vue2的一些问题，大型应用的性能问题、ts支持不友好问题，自定义渲染API解决体系架构存在的问题，如果在vue3的基础上实现weex框架会好很多。也做出了很多优化，Compostion API让代码的组织形式更好。vite开发构建工具让开发体验更好，Tree shaking让包更小、性能更优。</p> <p>总的来说vue3还是非常棒的，带来了很多非常好的新特性。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.f426d84b.js" defer></script><script src="/assets/js/10.598aec70.js" defer></script>
  </body>
</html>
