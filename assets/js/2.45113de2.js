(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{215:function(v,_,t){},260:function(v,_,t){v.exports=t.p+"assets/img/9.4d8caebb.png"},261:function(v,_,t){v.exports=t.p+"assets/img/1.bca330de.png"},262:function(v,_,t){v.exports=t.p+"assets/img/2.dcb426c4.png"},263:function(v,_,t){v.exports=t.p+"assets/img/3.662b8c3a.png"},264:function(v,_,t){v.exports=t.p+"assets/img/4.30e02ae4.png"},265:function(v,_,t){v.exports=t.p+"assets/img/5.01644a58.png"},266:function(v,_,t){v.exports=t.p+"assets/img/6.68d466b7.jpg"},267:function(v,_,t){v.exports=t.p+"assets/img/7.5303dab1.jpg"},268:function(v,_,t){v.exports=t.p+"assets/img/8.13d2a002.jpg"},269:function(v,_,t){"use strict";t(215)},341:function(v,_,t){"use strict";t.r(_);var e=[function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"http-高频面试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-高频面试"}},[v._v("#")]),v._v(" HTTP 高频面试")]),v._v(" "),e("h2",{attrs:{id:"什么是-http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-http"}},[v._v("#")]),v._v(" 什么是 HTTP ?")]),v._v(" "),e("p",[e("code",[v._v("HTTP")]),v._v(" 全称"),e("code",[v._v("超文本传输协议")]),v._v("是一种允许浏览器向服务器获取资源的协议，通常由浏览器发起请求，用来获取不同类型的文件，例如 "),e("code",[v._v("HTML")]),v._v(" 文件、"),e("code",[v._v("CSS")]),v._v(" 文件、"),e("code",[v._v("JavaScript")]),v._v(" 文件、图片、视频等。")]),v._v(" "),e("h2",{attrs:{id:"http-的特点和缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-的特点和缺点"}},[v._v("#")]),v._v(" HTTP 的特点和缺点?")]),v._v(" "),e("p",[e("strong",[v._v("特点：")]),v._v(" "),e("code",[v._v("无连接")]),v._v("、"),e("code",[v._v("无状态")]),v._v("、"),e("code",[v._v("灵活")]),v._v("、"),e("code",[v._v("简单快速")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("无连接")]),v._v("：每次请求结束后都要重新连接一次，不会保持连接 （"),e("code",[v._v("http 1.0")]),v._v("）")]),v._v(" "),e("li",[e("code",[v._v("无状态")]),v._v("：每一次请求都是独立的，请求结束后不会记录连接的任何信息，减少了网络开销，这是优点也是缺点")]),v._v(" "),e("li",[e("code",[v._v("灵活")]),v._v("：通过 "),e("code",[v._v("http")]),v._v(" 协议中头部的 "),e("code",[v._v("Content-Type")]),v._v(" 标记，可以传输任意数据类型的数据对象("),e("code",[v._v("文本")]),v._v("、"),e("code",[v._v("图片")]),v._v("、"),e("code",[v._v("视频")]),v._v("等等)，非常灵活")]),v._v(" "),e("li",[e("code",[v._v("简单快速")]),v._v("：当请求某个资源时，只需发送"),e("code",[v._v("请求方法")]),v._v("和 "),e("code",[v._v("URL")]),v._v(" 就可以了，使用简单")])]),v._v(" "),e("p",[e("strong",[v._v("缺点：")]),v._v(" "),e("code",[v._v("无状态")]),v._v("、"),e("code",[v._v("不安全")]),v._v("、"),e("code",[v._v("明文传输")]),v._v("、"),e("code",[v._v("队头阻塞")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("无状态")]),v._v("：用户的两次 "),e("code",[v._v("http")]),v._v(" 请求，服务端并不能通过请求本身来知道这两次请求是来自同一个用户")]),v._v(" "),e("li",[e("code",[v._v("不安全")]),v._v("：是因为 "),e("code",[v._v("http")]),v._v(" 是明文传输，且不能进行对其加密，其保存的信息可能被窃取")]),v._v(" "),e("li",[e("code",[v._v("明文传输")]),v._v("：明文传输会导致其信息会被窃取")]),v._v(" "),e("li",[e("code",[v._v("队头阻塞")]),v._v("：开启长连接时，只建立一个 "),e("code",[v._v("TCP")]),v._v(" 连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能处于阻塞状态")])]),v._v(" "),e("h2",{attrs:{id:"http-请求报文的组成成分？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-请求报文的组成成分？"}},[v._v("#")]),v._v(" HTTP 请求报文的组成成分？")]),v._v(" "),e("p",[e("code",[v._v("http")]),v._v(" 报文：由"),e("code",[v._v("请求报文")]),v._v("和"),e("code",[v._v("响应报文")]),v._v("组成")]),v._v(" "),e("p",[e("code",[v._v("请求报文")]),v._v("和"),e("code",[v._v("响应报文")]),v._v(" 分别由"),e("code",[v._v("起始行")]),v._v("、"),e("code",[v._v("HTTP头部")]),v._v("、"),e("code",[v._v("空行")]),v._v("和"),e("code",[v._v("实体")]),v._v("组成")]),v._v(" "),e("p",[e("code",[v._v("起始行：")])]),v._v(" "),e("ul",[e("li",[v._v("对于"),e("code",[v._v("请求报文")]),v._v("，起始行分别由"),e("code",[v._v("请求方法 + 路径 + HTTP协议及版本")]),v._v("组成")]),v._v(" "),e("li",[v._v("对于"),e("code",[v._v("响应报文")]),v._v("，起始行分别由"),e("code",[v._v("HTTP协议及版本 + 状态码 + 原因")]),v._v("组成")])]),v._v(" "),e("p",[e("code",[v._v("HTTP头部:")]),v._v(" 就是一些 "),e("code",[v._v("key: value")]),v._v(" 来告诉服务端我要哪些内容，要注意什么类型等")]),v._v(" "),e("p",[e("code",[v._v("空行：")]),v._v(" 用来区分"),e("code",[v._v("HTTP头部")]),v._v("和"),e("code",[v._v("实体")])]),v._v(" "),e("p",[e("code",[v._v("实体：")]),v._v(" 如果是"),e("code",[v._v("请求报文")]),v._v("，那就是请求参数，如果是"),e("code",[v._v("响应报文")]),v._v("，那就是服务器返回的数据")]),v._v(" "),e("p",[v._v("问: 如果说在头部中间故意加一个空行会怎么样？")]),v._v(" "),e("p",[v._v("那么空行后的内容全部被视为实体。")]),v._v(" "),e("h2",{attrs:{id:"http-的请求方法？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-的请求方法？"}},[v._v("#")]),v._v(" HTTP 的请求方法？")]),v._v(" "),e("p",[e("strong",[v._v("http1.0：")]),v._v(" "),e("code",[v._v("GET")]),v._v("、"),e("code",[v._v("POST")]),v._v("、"),e("code",[v._v("HEAD")])]),v._v(" "),e("p",[e("strong",[v._v("http1.1：")]),v._v(" "),e("code",[v._v("PUT")]),v._v("、"),e("code",[v._v("PATCH")]),v._v("、"),e("code",[v._v("DELETE")]),v._v("、"),e("code",[v._v("CONNECT")]),v._v("、"),e("code",[v._v("OPTIONS")]),v._v("、"),e("code",[v._v("TRACE")]),v._v("、")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("方法")]),v._v(" "),e("th",[v._v("描述")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("GET")]),v._v(" "),e("td",[v._v("通常用来获取资源")])]),v._v(" "),e("tr",[e("td",[v._v("POST")]),v._v(" "),e("td",[v._v("提交数据，即上传数据")])]),v._v(" "),e("tr",[e("td",[v._v("HEAD")]),v._v(" "),e("td",[v._v("获取资源的元信息")])]),v._v(" "),e("tr",[e("td",[v._v("PUT")]),v._v(" "),e("td",[v._v("修改数据")])]),v._v(" "),e("tr",[e("td",[v._v("DELETE")]),v._v(" "),e("td",[v._v("删除资源(几乎用不到)")])]),v._v(" "),e("tr",[e("td",[v._v("CONNECT")]),v._v(" "),e("td",[v._v("建立连接隧道，通常用于代理服务器")])]),v._v(" "),e("tr",[e("td",[v._v("OPTIONS")]),v._v(" "),e("td",[v._v("列出可对资源实行的请求方法，通常用来跨域请求")])]),v._v(" "),e("tr",[e("td",[v._v("TRACE")]),v._v(" "),e("td",[v._v("追踪请求-响应的传输路径")])])])]),v._v(" "),e("h2",{attrs:{id:"get-和-post-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[v._v("#")]),v._v(" GET 和 POST 的区别?")]),v._v(" "),e("p",[v._v("主要有以下几个角度来分析：")]),v._v(" "),e("ul",[e("li",[v._v("从语义上的角度，"),e("code",[v._v("GET")]),v._v(" 请求通常用来获取资源，而 "),e("code",[v._v("POST")]),v._v(" 请求是提交数据，即上传数据。")]),v._v(" "),e("li",[v._v("从缓存的角度，"),e("code",[v._v("GET")]),v._v(" 请求会被浏览器主动缓存下来，留下历史记录，而 "),e("code",[v._v("POST")]),v._v(" 默认不会。")]),v._v(" "),e("li",[v._v("从编码的角度，"),e("code",[v._v("GET")]),v._v(" 请求只能进行 "),e("code",[v._v("URL")]),v._v(" 编码，只能接受 "),e("code",[v._v("ASCII")]),v._v(" 字符，而 "),e("code",[v._v("POST")]),v._v(" 没有限制。")]),v._v(" "),e("li",[v._v("从参数的角度，"),e("code",[v._v("GET")]),v._v(" 请求一般放在 "),e("code",[v._v("URL")]),v._v(" 中，因此不安全，"),e("code",[v._v("POST")]),v._v(" 放在请求体中，更适合传输敏感信息。")]),v._v(" "),e("li",[v._v("从幂等性的角度，"),e("code",[v._v("GET")]),v._v(" 请求是幂等的，而 "),e("code",[v._v("POST")]),v._v(" 不是。(幂等表示执行相同的操作，结果也是相同的)")]),v._v(" "),e("li",[v._v("从 "),e("code",[v._v("TCP")]),v._v(" 的角度，"),e("code",[v._v("GET")]),v._v(" 请求会把请求报文一次性发出去，而 "),e("code",[v._v("POST")]),v._v(" 请求会分为两个 "),e("code",[v._v("TCP")]),v._v(" 数据包，首先发 "),e("code",[v._v("header")]),v._v(" 部分， 如果服务端响应 "),e("code",[v._v("100")]),v._v("，然后发 "),e("code",[v._v("body")]),v._v(" 部分。(火狐浏览器除外，它的 "),e("code",[v._v("POST")]),v._v(" 请求只发一个 "),e("code",[v._v("TCP")]),v._v(" 包)")])]),v._v(" "),e("h2",{attrs:{id:"常见的-http-状态码？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的-http-状态码？"}},[v._v("#")]),v._v(" 常见的 HTTP 状态码？")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[v._v("状态码")]),v._v(" "),e("th",{staticStyle:{"text-align":"left"}},[v._v("描述")])])]),v._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("1xx（协议的中间状态）")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("101")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("在 "),e("code",[v._v("HTTP")]),v._v(" 升级为 "),e("code",[v._v("WebSocket")]),v._v(" 的时候，如果服务器同意变更，就会发送状态码 "),e("code",[v._v("101")])])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("2xx（请求成功）")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("200 ok")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("表示请求成功，数据正常返回")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("204")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("表示请求成功，但是服务端没有内容给你")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("3xx（重定向）")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("301")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("永久重定向(当访问一个永久重定向的网站的时候,一个域名被指向一个其他网站,且是 永久的)，会缓存")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("302")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("临时重定向，不会缓存，但是会在重定向的时候改变 method: 把 POST 请求改成 GET 请求")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("304")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("走缓存(服务端觉得你之前请求过这个东西,而且服务器上的那一份没有发生变化,告诉客户端用缓存就行)")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("307")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("临时重定向，在重定向时不会改变 method")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("4xx（客户端错误）")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("400")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("参数传递不当，导致的错误，请求错误")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("401")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("权限不够导致的")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("403")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("服务端已经理解请求，但是拒绝响应")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("404")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("客户端请求的资源或者数据不存在(发现请求接口 404，有两种情况一种是咱们写错接口了或者服务端还没部署)")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("5xx（服务端错误）")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("500")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("服务端内部错误")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("502")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("网关错误")])]),v._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[v._v("503")]),v._v(" "),e("td",{staticStyle:{"text-align":"left"}},[v._v("服务器繁忙")])])])]),v._v(" "),e("h2",{attrs:{id:"什么是持久链接-长连接？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是持久链接-长连接？"}},[v._v("#")]),v._v(" 什么是持久链接/长连接？")]),v._v(" "),e("p",[e("code",[v._v("http1.0")]),v._v(" 协议采用的是"),e("code",[v._v("请求-应答")]),v._v("模式，也就是说，每次 "),e("code",[v._v("HTTP")]),v._v(" 请求结束后，都必须重新建立一个 "),e("code",[v._v("TCP")]),v._v(" 连接")]),v._v(" "),e("p",[e("code",[v._v("http1.1")]),v._v(" 版本支持长连接，即请求头添加 "),e("code",[v._v("Connection: Keep-Alive")]),v._v("，使用 "),e("code",[v._v("Keep-Alive")]),v._v(" 模式(又称持久连接，连接复用)建立一个 "),e("code",[v._v("TCP")]),v._v(" 连接后使"),e("code",[v._v("客户端到服务端的连接持续有效")]),v._v("，\n并且可以发送多个 "),e("code",[v._v("http")]),v._v(" 请求，使用 "),e("code",[v._v("Keep-Alive")]),v._v(" 模式避免了 "),e("code",[v._v("TCP")]),v._v(" 的重新建立连接")]),v._v(" "),e("p",[e("strong",[v._v("长连接优缺点")])]),v._v(" "),e("p",[e("strong",[v._v("优点：")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("减少 CPU 及内存的使用")]),v._v("，因为不需要经常建立和关闭连接")]),v._v(" "),e("li",[e("code",[v._v("支持管道化")]),v._v("的请求及响应模式")]),v._v(" "),e("li",[e("code",[v._v("减少网络堵塞")]),v._v("，因为减少了TCP请求")]),v._v(" "),e("li",[e("code",[v._v("减少了后续请求的响应时间")]),v._v("，因为不需要等待建立TCP、握手、挥手、关闭TCP的过程")]),v._v(" "),e("li",[e("code",[v._v("发生错误时")]),v._v("，也可在不关闭连接的情况下进行错误提示")])]),v._v(" "),e("p",[e("strong",[v._v("缺点：")])]),v._v(" "),e("ul",[e("li",[v._v("一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，而且长连接时间的长短，直接影响到服务器的并发数")]),v._v(" "),e("li",[e("code",[v._v("可能会造成队头堵塞")])])]),v._v(" "),e("h2",{attrs:{id:"什么是管线化-管道化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是管线化-管道化"}},[v._v("#")]),v._v(" 什么是管线化(管道化)")]),v._v(" "),e("p",[v._v("管线化是在同一个 "),e("code",[v._v("TCP")]),v._v(" 连接里发一个请求后不必等其回来就可以继续发送请求，这可以减少整体的响应时间，但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题"),e("code",[v._v("队头堵塞")])]),v._v(" "),e("h2",{attrs:{id:"如何解决-http-的队头阻塞问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何解决-http-的队头阻塞问题"}},[v._v("#")]),v._v(" 如何解决 HTTP 的队头阻塞问题")]),v._v(" "),e("p",[e("code",[v._v("http1.1")]),v._v(" 版本支持长连接，也同时支持管道化的连接方式，管线化是在同一个 "),e("code",[v._v("TCP")]),v._v(" 连接里发一个请求后不必等其回来就可以继续发送请求，这可以减少整体的响应时间，\n但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，其他请求就只能处于阻塞状态，因此就叫"),e("code",[v._v("队头堵塞")]),v._v("。解决如下：")]),v._v(" "),e("p",[e("strong",[v._v("并发连接")])]),v._v(" "),e("p",[v._v("因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。以前在 "),e("code",[v._v("RFC2616")]),v._v(" 中规定过客户端最多只能并发 "),e("code",[v._v("2")]),v._v(" 个连接，\n但是现实是很多浏览器不按套路出牌，就是遵守这个标准 "),e("code",[v._v("T_T")]),v._v("，所以在 "),e("code",[v._v("RFC7230")]),v._v(" 把这个规定取消掉了，现在的浏览器标准中一个域名并发连接可以有 "),e("code",[v._v("6~8")]),v._v(" 个，记住是 "),e("code",[v._v("6~8")]),v._v(" 个，\n不是 "),e("code",[v._v("6")]),v._v(" 个("),e("code",[v._v("Chrome 6")]),v._v(" 个/ "),e("code",[v._v("Firefox 8")]),v._v(" 个)")]),v._v(" "),e("p",[e("strong",[v._v("域名分片")])]),v._v(" "),e("p",[v._v("一个域名最多可以并发 "),e("code",[v._v("6~8")]),v._v(" 个，那咱就多来几个域名\n比如 "),e("code",[v._v("a.baidu.com")]),v._v("，"),e("code",[v._v("b.baidu.com")]),v._v("，"),e("code",[v._v("c.baidu.com")]),v._v("，多准备几个二级域名，当我们访问 "),e("code",[v._v("baidu.com")]),v._v(" 时，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了\n而在 "),e("code",[v._v("HTTP2.0")]),v._v(" 下，可以一瞬间加载出来很多资源，因为支持多路复用，可以在一个 "),e("code",[v._v("TCP")]),v._v(" 连接中发送多个请求")]),v._v(" "),e("h2",{attrs:{id:"http-和-https-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-区别"}},[v._v("#")]),v._v(" HTTP 和 HTTPS 区别")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("HTTP")]),v._v(" 的 "),e("code",[v._v("URL")]),v._v(" 以 "),e("code",[v._v("http://")]),v._v(" 开头，而 "),e("code",[v._v("HTTPS")]),v._v(" 的 "),e("code",[v._v("URL")]),v._v(" 以 "),e("code",[v._v("https://")]),v._v(" 开头")]),v._v(" "),e("li",[e("code",[v._v("HTTP")]),v._v(" 是"),e("code",[v._v("明文传输")]),v._v(", 因此是不安全的，而 "),e("code",[v._v("HTTPS")]),v._v(" 是"),e("code",[v._v("加密传输")]),v._v("，因此是安全的")]),v._v(" "),e("li",[e("code",[v._v("HTTP")]),v._v(" 标准端口是 "),e("code",[v._v("80")]),v._v(" ，而 "),e("code",[v._v("HTTPS")]),v._v(" 的标准端口是 "),e("code",[v._v("443")])]),v._v(" "),e("li",[v._v("在"),e("code",[v._v("OSI")]),v._v(" 网络模型中，"),e("code",[v._v("HTTP")]),v._v(" 工作于应用层，而 "),e("code",[v._v("HTTPS")]),v._v(" 的安全传输机制("),e("code",[v._v("TLS")]),v._v(")工作在传输层")]),v._v(" "),e("li",[e("code",[v._v("HTTP")]),v._v(" 无法加密，而 "),e("code",[v._v("HTTPS")]),v._v(" 对传输的数据进行加密")]),v._v(" "),e("li",[e("code",[v._v("HTTP")]),v._v("无需证书，而 "),e("code",[v._v("HTTPS")]),v._v(" 需要 "),e("code",[v._v("CA")]),v._v(" 机构 "),e("code",[v._v("wosign")]),v._v(" 的颁发的 "),e("code",[v._v("SSL")]),v._v(" 证书")]),v._v(" "),e("li",[e("code",[v._v("HTTP")]),v._v(" 是无状态的，"),e("code",[v._v("HTTPS")]),v._v(" 是有状态的")]),v._v(" "),e("li",[v._v("连接方式不同，"),e("code",[v._v("HTTP")]),v._v(" 三次握手，"),e("code",[v._v("HTTPS")]),v._v(" 中 "),e("code",[v._v("TLS1.2")]),v._v(" 版本 "),e("code",[v._v("7")]),v._v(" 次，"),e("code",[v._v("TLS1.3")]),v._v(" 版本 "),e("code",[v._v("6")]),v._v(" 次")])])]),v._v(" "),e("h2",{attrs:{id:"http1-和-http2-的区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-和-http2-的区别？"}},[v._v("#")]),v._v(" HTTP1 和 HTTP2 的区别？")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("http2")]),v._v(" 采用二进制格式而非文本格式。")]),v._v(" "),e("li",[e("code",[v._v("http2")]),v._v(" 是完全多路复用的，而非有序并阻塞的。")]),v._v(" "),e("li",[e("code",[v._v("http2")]),v._v(" 采用了报头压缩，降低了成本。")]),v._v(" "),e("li",[e("code",[v._v("http2")]),v._v(" 让服务器可以主动将响应推送到客户端缓存中")])])]),v._v(" "),e("h3",{attrs:{id:"多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[v._v("#")]),v._v(" 多路复用")]),v._v(" "),e("p",[v._v("每个 "),e("code",[v._v("HTTP")]),v._v(" 请求都有一个序列标识符，这样浏览器可以并发多个请求，服务器接收到数据后，再根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且同一个域名下的所有请求都复用同一个 "),e("code",[v._v("TCP")]),v._v(" 连接，极大增加了服务器处理并发的上限。")]),v._v(" "),e("h4",{attrs:{id:"http-队头阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-队头阻塞"}},[v._v("#")]),v._v(" HTTP 队头阻塞")]),v._v(" "),e("p",[v._v("而 "),e("code",[v._v("HTTP/2")]),v._v(" 便从 "),e("code",[v._v("HTTP")]),v._v(" 协议本身解决了队头阻塞问题。注意，这里并不是指的 "),e("code",[v._v("TCP")]),v._v(" 队头阻塞，而是 "),e("code",[v._v("HTTP")]),v._v(" 队头阻塞，两者并不是一回事。"),e("code",[v._v("TCP")]),v._v(" 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 "),e("code",[v._v("HTTP")]),v._v("，而 "),e("code",[v._v("HTTP")]),v._v(" 的队头阻塞是在 "),e("code",[v._v("HTTP")]),v._v(" 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。")]),v._v(" "),e("p",[v._v("那么 "),e("code",[v._v("HTTP/2")]),v._v(" 如何来解决所谓的队头阻塞呢？")]),v._v(" "),e("h4",{attrs:{id:"二进制分帧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧"}},[v._v("#")]),v._v(" 二进制分帧")]),v._v(" "),e("p",[e("code",[v._v("HTTP2")]),v._v(" 采用二进制格式传输，取代了 "),e("code",[v._v("HTTP1.x")]),v._v(" 的文本格式，二进制格式解析更高效。")]),v._v(" "),e("p",[v._v("原来 "),e("code",[v._v("Headers + Body")]),v._v(" 的报文格式如今被拆分成了一个个二进制的帧，用 "),e("code",[v._v("Headers")]),v._v(" 帧存放头部字段，"),e("code",[v._v("Data")]),v._v(" 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 "),e("code",[v._v("HTTP")]),v._v(" 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。")]),v._v(" "),e("p",[v._v("多路复用代替了 "),e("code",[v._v("HTTP1.x")]),v._v(" 的序列和阻塞机制，所有的相同域名请求都通过同一 个 "),e("code",[v._v("TCP")]),v._v(" 连接并发完成。")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("HTTP1.x")]),v._v(" 中，并发多个请求需要多个 "),e("code",[v._v("TCP")]),v._v(" 连接，浏览器为了控制资源会有 "),e("code",[v._v("6-8")]),v._v(" 个 "),e("code",[v._v("TCP")]),v._v(" 连接的限制。"),e("code",[v._v("HTTP2")]),v._v(" 中同域名下所有通信都在单个连接上完成，消除了因多个 "),e("code",[v._v("TCP")]),v._v(" 连接而带来的延时和内存消耗。")]),v._v(" "),e("p",[v._v("单个连接上可以并行交错的请求和响应，之间互不干扰")]),v._v(" "),e("p",[v._v("通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流("),e("code",[v._v("Stream")]),v._v(")。"),e("code",[v._v("HTTP/2")]),v._v(" 用流来在一个 "),e("code",[v._v("TCP")]),v._v(" 连接上来进行多个数据帧的通信，这就是多路复用的概念。\n可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？")]),v._v(" "),e("p",[v._v("首先要声明的是，所谓的乱序，指的是不同 "),e("code",[v._v("ID")]),v._v(" 的 "),e("code",[v._v("Stream")]),v._v(" 是乱序的，但同一个 "),e("code",[v._v("Stream ID")]),v._v(" 的帧一定是按顺序传输的。二进制帧到达后对方会将 "),e("code",[v._v("Stream ID")]),v._v(" 相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能，我们放到下一节再来介绍。")]),v._v(" "),e("p",[e("strong",[v._v("HTTP、HTTPS 以及 HTTP2，如下图所示：")])]),v._v(" "),e("p",[e("img",{attrs:{src:t(260),alt:""}})]),v._v(" "),e("h2",{attrs:{id:"浏览器缓存问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存问题？"}},[v._v("#")]),v._v(" 浏览器缓存问题？")]),v._v(" "),e("h3",{attrs:{id:"什么是缓存呢？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存呢？"}},[v._v("#")]),v._v(" 什么是缓存呢？")]),v._v(" "),e("p",[v._v("当首次进入一个网站，电脑会把这个网站的一些图片和数据等资源缓存在电脑上，当第二次访问这个网站时，浏览器就会自动帮助我们加载出来，这就是缓存")]),v._v(" "),e("h3",{attrs:{id:"缓存有哪些好处？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存有哪些好处？"}},[v._v("#")]),v._v(" 缓存有哪些好处？")]),v._v(" "),e("ul",[e("li",[e("ol",[e("li",[v._v("缓解服务器压力，不用每次都去请求某些数据了。")])])]),v._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[v._v("提升性能，打开本地资源肯定会比请求服务器来的快。")])])]),v._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[v._v("减少带宽消耗，当我们使用缓存时，只会产生很小的网络消耗。")])])])]),v._v(" "),e("h3",{attrs:{id:"web缓存种类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web缓存种类"}},[v._v("#")]),v._v(" Web缓存种类")]),v._v(" "),e("p",[v._v("数据库缓存，CDN缓存，代理服务器缓存，浏览器缓存")]),v._v(" "),e("p",[e("strong",[v._v("浏览器缓存过程：")]),v._v(" 强缓存，协商缓存。")]),v._v(" "),e("p",[e("strong",[v._v("浏览器缓存位置一般分为四类：")]),v._v("  Service Worker--\x3eMemory Cache--\x3eDisk Cache--\x3ePush Cache。")]),v._v(" "),e("h3",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),e("p",[v._v("强缓存是当我们访问 "),e("code",[v._v("URL")]),v._v(" 的时候，不会向服务器发送请求，直接从缓存中读取数据，并且会返回 "),e("code",[v._v("200")]),v._v(" 的状态码")]),v._v(" "),e("h3",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),e("p",[v._v("协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。")]),v._v(" "),e("p",[v._v("主要有以下两种情况：")]),v._v(" "),e("ul",[e("li",[v._v("协商缓存生效，返回 "),e("code",[v._v("304")])]),v._v(" "),e("li",[v._v("协商缓存失效，返回 "),e("code",[v._v("200")]),v._v(" 和全新的资源")])]),v._v(" "),e("h4",{attrs:{id:"如何设置强缓存？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何设置强缓存？"}},[v._v("#")]),v._v(" 如何设置强缓存？")]),v._v(" "),e("p",[v._v("第一次请求时，浏览器会根据响应头来判断是否对资源进行缓存，如果响应头中有 "),e("code",[v._v("expires")]),v._v("、"),e("code",[v._v("pragma")]),v._v(" 或者 "),e("code",[v._v("cache-control")]),v._v(" 字段，代表这是强缓存，\n不会向服务器发送请求，浏览器就会把资源缓存在 "),e("code",[v._v("memory cache")]),v._v(" 或 "),e("code",[v._v("disk cache")]),v._v(" 中。")]),v._v(" "),e("p",[v._v("第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接从缓存中读取数据，并且会返回 "),e("code",[v._v("200")]),v._v(" 的状态码。否则浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来看是否符合协商缓存，\n符合则返回状态码 "),e("code",[v._v("304")]),v._v("，不符合则返回 "),e("code",[v._v("200")]),v._v(" 和全新的资源。")]),v._v(" "),e("img",{attrs:{src:t(261),width:"900"}}),v._v(" "),e("p",[e("strong",[v._v("expires")])]),v._v(" "),e("p",[v._v("是 "),e("code",[v._v("HTTP1.0")]),v._v(" 控制网页缓存的字段，值为一个时间戳，准确来讲是格林尼治时间，服务器返回该请求结果缓存的到期时间，意思是，再次发送请求时，如果未超过过期时间，直接使用该缓存，如果过期了则重新请求。\n有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。")]),v._v(" "),e("p",[e("strong",[v._v("Cache-Control")])]),v._v(" "),e("p",[v._v("是 "),e("code",[v._v("HTTP1.1")]),v._v(" 中控制网页缓存的字段，当 "),e("code",[v._v("Cache-Control")]),v._v(" 都存在时，"),e("code",[v._v("Cache-Control")]),v._v(" 优先级更高，主要取值为：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("public：")]),v._v("资源客户端和服务器都可以缓存。")]),v._v(" "),e("li",[e("code",[v._v("private：")]),v._v("资源只有客户端可以缓存。")]),v._v(" "),e("li",[e("code",[v._v("no-cache：")]),v._v("客户端缓存资源，但是是否缓存需要经过协商缓存来验证。")]),v._v(" "),e("li",[e("code",[v._v("no-store：")]),v._v("不使用缓存。")]),v._v(" "),e("li",[e("code",[v._v("max-age：")]),v._v("缓存保质期。")])]),v._v(" "),e("p",[e("strong",[v._v("pragma")])]),v._v(" "),e("p",[v._v("这个是 "),e("code",[v._v("HTTP1.0")]),v._v(" 中禁用网页缓存的字段，其取值为 "),e("code",[v._v("no-cache")]),v._v("，和 "),e("code",[v._v("Cache-Control")]),v._v(" 的 "),e("code",[v._v("no-cache")]),v._v(" 效果一样。")]),v._v(" "),e("img",{attrs:{src:t(262),width:"700"}}),v._v(" "),e("h4",{attrs:{id:"如何设置协商缓存？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何设置协商缓存？"}},[v._v("#")]),v._v(" 如何设置协商缓存？")]),v._v(" "),e("p",[e("strong",[v._v("Last-Modified / If-Modified-Since")])]),v._v(" "),e("p",[e("code",[v._v("Last-Modified")]),v._v(" 是服务器响应请求时，返回该资源在服务器最后被修改的时间。")]),v._v(" "),e("p",[e("code",[v._v("If-Modified-Since")]),v._v(" 则是客户端再次发起该请求时，携带上次请求返回的 "),e("code",[v._v("Last-Modified")]),v._v(" 值，服务器收到该请求，会根据 "),e("code",[v._v("If-Modified-Since")]),v._v(" 的字段值与该资源在服务器的最后被修改时间做对比，\n若服务器的资源最后被修改时间大于 "),e("code",[v._v("If-Modified-Since")]),v._v(" 的字段值，则返回全新的资源，状态码为 "),e("code",[v._v("200")]),v._v("；否则则返回 "),e("code",[v._v("304")]),v._v("，代表资源无更新，可继续使用缓存文件。")]),v._v(" "),e("p",[e("strong",[v._v("Etag / If-None-Match")])]),v._v(" "),e("p",[e("code",[v._v("Etag")]),v._v(" 是服务器响应请求时，返回当前资源文件的唯一标识(由服务器生成)。")]),v._v(" "),e("p",[e("code",[v._v("If-None-Match")]),v._v(" 是客户端再次发起该请求时，携带上次请求返回的唯一标识 "),e("code",[v._v("Etag")]),v._v(" 值，会根据 "),e("code",[v._v("If-None-Match")]),v._v(" 的字段值与该资源在服务器的 "),e("code",[v._v("Etag")]),v._v(" 值做对比，\n一致则返回 "),e("code",[v._v("304")]),v._v("，代表资源无更新，继续使用缓存；不一致则返回全新的资源，状态码为 "),e("code",[v._v("200")]),v._v("。")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[e("code",[v._v("Etag / If-None-Match")]),v._v(" 优先级高于 "),e("code",[v._v("Last-Modified / If-Modified-Since")]),v._v("，同时存在则只有 "),e("code",[v._v("Etag / If-None-Match")]),v._v(" 生效。")])]),v._v(" "),e("p",[e("strong",[v._v("Etag如何生成")])]),v._v(" "),e("p",[e("code",[v._v("nginx")]),v._v(" 中 "),e("code",[v._v("etag")]),v._v(" 由响应头的 "),e("code",[v._v("Last-Modified")]),v._v(" 与 "),e("code",[v._v("Content-Length")]),v._v(" 表示为十六进制组合而成")]),v._v(" "),e("h2",{attrs:{id:"浏览器存储方式有哪些？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器存储方式有哪些？"}},[v._v("#")]),v._v(" 浏览器存储方式有哪些？")]),v._v(" "),e("p",[v._v("浏览器存储方式主要有 "),e("code",[v._v("cookie")]),v._v("、"),e("code",[v._v("localStorage")]),v._v("、"),e("code",[v._v("sessionStorage")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"为什么会出现-cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么会出现-cookie"}},[v._v("#")]),v._v(" 为什么会出现 cookie?")]),v._v(" "),e("p",[e("code",[v._v("Cookie")]),v._v(" 它的出现是为了解决 "),e("code",[v._v("HTTP")]),v._v(" 协议无状态特性的问题 简单理解就是：用户的两次 "),e("code",[v._v("HTTP")]),v._v(" 请求，服务端并不能通过请求本身来知道这两次请求是来自于同一个用户")]),v._v(" "),e("h3",{attrs:{id:"cookie-生存周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-生存周期"}},[v._v("#")]),v._v(" Cookie 生存周期")]),v._v(" "),e("p",[e("code",[v._v("Cookie")]),v._v(" 的有效期可以通过 "),e("code",[v._v("Expires")]),v._v(" 和 "),e("code",[v._v("Max-Age")]),v._v(" 两个属性来设置。")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Expires")]),v._v(" 即过期时间")]),v._v(" "),e("li",[e("code",[v._v("Max-Age")]),v._v(" 用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。")])]),v._v(" "),e("p",[v._v("若 "),e("code",[v._v("Cookie")]),v._v(" 过期，则这个 "),e("code",[v._v("Cookie")]),v._v(" 会被删除，并不会发送给服务端。")]),v._v(" "),e("h3",{attrs:{id:"作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[v._v("#")]),v._v(" 作用域")]),v._v(" "),e("p",[v._v("关于作用域也有两个属性: "),e("code",[v._v("Domain")]),v._v(" 和 "),e("code",[v._v("path")]),v._v(", 给 "),e("code",[v._v("Cookie")]),v._v(" 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 "),e("code",[v._v("Cookie")]),v._v("。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 "),e("code",[v._v("Cookie")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"安全相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全相关"}},[v._v("#")]),v._v(" 安全相关")]),v._v(" "),e("p",[v._v("如果带上 "),e("code",[v._v("Secure")]),v._v("，说明只能通过 "),e("code",[v._v("HTTPS")]),v._v(" 传输 "),e("code",[v._v("cookie。")])]),v._v(" "),e("p",[v._v("如果 "),e("code",[v._v("cookie")]),v._v(" 字段带上 "),e("code",[v._v("HttpOnly")]),v._v("，那么说明只能通过 "),e("code",[v._v("HTTP")]),v._v(" 协议传输，不能通过 "),e("code",[v._v("JS")]),v._v(" 访问，这也是预防 "),e("code",[v._v("XSS")]),v._v(" 攻击的重要手段。")]),v._v(" "),e("p",[v._v("相应的，对于 "),e("code",[v._v("CSRF")]),v._v(" 攻击的预防，也有 "),e("code",[v._v("SameSite")]),v._v(" 属性。")]),v._v(" "),e("p",[e("code",[v._v("SameSite")]),v._v(" 可以设置为三个值，"),e("code",[v._v("Strict")]),v._v("、"),e("code",[v._v("Lax")]),v._v(" 和 "),e("code",[v._v("None")]),v._v("。")]),v._v(" "),e("ul",[e("li",[v._v("a. 在 "),e("code",[v._v("Strict")]),v._v(" 模式下，浏览器完全禁止第三方请求携带 "),e("code",[v._v("Cookie")]),v._v("。比如请求 "),e("code",[v._v("sanyuan.com")]),v._v(" 网站只能在 "),e("code",[v._v("sanyuan.com")]),v._v(" 域名当中请求才能携带 "),e("code",[v._v("Cookie")]),v._v("，在其他网站请求都不能。")]),v._v(" "),e("li",[v._v("b. 在 "),e("code",[v._v("Lax")]),v._v(" 模式，就宽松一点了，但是只能在 "),e("code",[v._v("get")]),v._v(" 方法提交表单况或者 "),e("code",[v._v("a")]),v._v(" 标签发送 "),e("code",[v._v("get")]),v._v(" 请求的情况下可以携带 "),e("code",[v._v("Cookie")]),v._v("，其他情况均不能。")]),v._v(" "),e("li",[v._v("c. 在 "),e("code",[v._v("None")]),v._v(" 模式下，也就是默认模式，请求会自动携带上 "),e("code",[v._v("Cookie")]),v._v("。")])]),v._v(" "),e("h3",{attrs:{id:"cookie-的安全问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的安全问题"}},[v._v("#")]),v._v(" Cookie 的安全问题?")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[e("code",[v._v("Cookie")]),v._v(" 在每次请求中都会被发送，如果不使用 "),e("code",[v._v("HTTPS")]),v._v(" 并对其加密，其保存的信息很容易被窃取，导致安全风险"),e("br"),v._v(" "),e("code",[v._v("Cookie")]),v._v(" 每次请求自动发送的特性还会导致 "),e("code",[v._v("CSRF")]),v._v(" 攻击的安全风险")])]),v._v(" "),e("h3",{attrs:{id:"cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[v._v("#")]),v._v(" Cookie")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("ol",[e("li",[v._v("可设置失效时间，没有设置的话，默认是关闭浏览器后失效")]),v._v(" "),e("li",[v._v("存放数据大小："),e("code",[v._v("4KB")]),v._v(" 左右")]),v._v(" "),e("li",[v._v("每次请求都会携带在 "),e("code",[v._v("HTTP")]),v._v(" 头中，如果使用 "),e("code",[v._v("Cookie")]),v._v(" 保存过多数据会带来性能问题")]),v._v(" "),e("li",[v._v("需要自己封装，原生的 "),e("code",[v._v("Cookie")]),v._v(" 接口不友好")])])]),v._v(" "),e("h3",{attrs:{id:"localstorage-sessionstorage"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#localstorage-sessionstorage"}},[v._v("#")]),v._v(" localStorage / sessionStorage")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("localStorage")]),v._v(": 除非被手动清除，否则将会永久保存。\n"),e("code",[v._v("sessionStorage")]),v._v(":  只在当前网页下有效，关闭页面或浏览器后就会被清除。")]),v._v(" "),e("li",[v._v("都可以保存 "),e("code",[v._v("5MB")]),v._v(" 的信息。")]),v._v(" "),e("li",[v._v("都仅在客户端（即浏览器）中保存，不参与和服务器的通信")]),v._v(" "),e("li",[v._v("原生接口比较友好，也可再次封装来对 "),e("code",[v._v("Object")]),v._v(" 和 "),e("code",[v._v("Array")]),v._v(" 有更好的支持")])])]),v._v(" "),e("h2",{attrs:{id:"了解-accept-相关字段？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#了解-accept-相关字段？"}},[v._v("#")]),v._v(" 了解 Accept 相关字段？")]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("Accept")]),v._v(" 系列字段的介绍分为四个部分: "),e("code",[v._v("数据格式")]),v._v("、"),e("code",[v._v("压缩方式")]),v._v("、"),e("code",[v._v("支持语言")]),v._v("和"),e("code",[v._v("字符集")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"数据格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据格式"}},[v._v("#")]),v._v(" 数据格式")]),v._v(" "),e("p",[v._v("不过首先需要介绍一个标准——MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 "),e("code",[v._v("HTTP")]),v._v(" 来说也是通用的。\n因此，"),e("code",[v._v("HTTP")]),v._v(" 从 "),e("code",[v._v("MIME type")]),v._v(" 取了一部分来标记报文 "),e("code",[v._v("body")]),v._v(" 部分的数据类型，这些类型体现在 "),e("code",[v._v("Content-Type")]),v._v(" 这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用 "),e("code",[v._v("Accept")]),v._v(" 字段。")]),v._v(" "),e("p",[v._v("具体而言，这两个字段的取值可以分为下面几类:")]),v._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[v._v("text： text/html, text/plain, text/css 等\nimage: image/gif, image/jpeg, image/png 等\naudio/video: audio/mpeg, video/mp4 等\napplication: application/json, application/javascript, application/pdf, application/octet-stream\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br")])]),e("h3",{attrs:{id:"压缩方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩方式"}},[v._v("#")]),v._v(" 压缩方式")]),v._v(" "),e("p",[v._v("当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的 "),e("code",[v._v("Content-Encoding")]),v._v(" 字段上， 同样的，接收什么样的压缩方式体现在了接受方的 "),e("code",[v._v("Accept-Encoding")]),v._v(" 字段上。这个字段的取值有下面几种：")]),v._v(" "),e("p",[e("code",[v._v("gzip")]),v._v(": 当今最流行的压缩格式\n"),e("code",[v._v("deflate")]),v._v(": 另外一种著名的压缩格式\n"),e("code",[v._v("br")]),v._v(": 一种专门为 "),e("code",[v._v("HTTP")]),v._v(" 发明的压缩算法")]),v._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[v._v("// 发送端\nContent-Encoding: "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("gzip")]),v._v("\n// 接收端\nAccept-Encoding: "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("gzip")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br")])]),e("h3",{attrs:{id:"支持语言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#支持语言"}},[v._v("#")]),v._v(" 支持语言")]),v._v(" "),e("p",[v._v("对于发送方而言，还有一个 "),e("code",[v._v("Content-Language")]),v._v(" 字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为 "),e("code",[v._v("Accept-Language")]),v._v("。如:")]),v._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[v._v("// 发送端\nContent-Language: zh-CN, zh, en\n// 接收端\nAccept-Language: zh-CN, zh, en\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br")])]),e("h3",{attrs:{id:"代码字符集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码字符集"}},[v._v("#")]),v._v(" 代码字符集")]),v._v(" "),e("p",[v._v("最后是一个比较特殊的字段, 在接收端对应为 "),e("code",[v._v("Accept-Charset")]),v._v("，指定可以接受的字符集，而在发送端并没有对应的 "),e("code",[v._v("Content-Charset")]),v._v(", 而是直接放在了 "),e("code",[v._v("Content-Type")]),v._v(" 中，以 "),e("code",[v._v("charset")]),v._v(" 属性指定。如:")]),v._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[v._v("// 发送端\nContent-Type: text/html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[v._v("charset")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("utf-8\n// 接收端\nAccept-Charset: "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[v._v("charset")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("utf-8\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br")])]),e("p",[v._v("最后以一张图来总结一下吧")]),v._v(" "),e("img",{staticStyle:{width:"80%"},attrs:{src:t(263)}}),v._v(" "),e("h2",{attrs:{id:"说一说三次握手？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一说三次握手？"}},[v._v("#")]),v._v(" 说一说三次握手？")]),v._v(" "),e("p",[e("img",{attrs:{src:t(264),alt:""}})]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("三次握手:"),e("br"),v._v("\n第一次握手：客户端向服务端发送 "),e("code",[v._v("SYN")]),v._v(" 码数据包，表示客户端要求和服务端建立连接；"),e("br"),v._v("\n第二次握手：服务端收到客户端的连接请求后，会发送 "),e("code",[v._v("ACK")]),v._v(" 码数据包给客户端，表示客户端是否真的需要建立连接；"),e("br"),v._v("\n第三次握手：客户端收到 "),e("code",[v._v("ACK")]),v._v(" 码以后会检验是否正确，如果正确，客户端会再次发送 "),e("code",[v._v("ACK")]),v._v(" 码给服务端，表示确认建立连接；"),e("br"),v._v("\n(三次握手都成功以后才会建立连接，然后才会发送数据；)")])]),v._v(" "),e("h3",{attrs:{id:"为什么-tcp-连接需要3次握手，而不是两次"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-tcp-连接需要3次握手，而不是两次"}},[v._v("#")]),v._v(" 为什么 TCP 连接需要3次握手，而不是两次")]),v._v(" "),e("p",[v._v("为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误")]),v._v(" "),e("h3",{attrs:{id:"为什么-tcp-连接不是四次握手？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-tcp-连接不是四次握手？"}},[v._v("#")]),v._v(" 为什么 TCP 连接不是四次握手？")]),v._v(" "),e("p",[v._v("当然可以，三次握手的目的是确认双方发送和接收的能力，但为了解决问题，三次就足够了，再多用处就不大了。")]),v._v(" "),e("h2",{attrs:{id:"说一说四次挥手？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一说四次挥手？"}},[v._v("#")]),v._v(" 说一说四次挥手？")]),v._v(" "),e("p",[e("img",{attrs:{src:t(265),alt:""}})]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("四次挥手："),e("br"),v._v("\n第一次挥手：客户端向服务端发送 "),e("code",[v._v("FIN")]),v._v(" 码数据包，表示客户端的数据已经传递完了。"),e("br"),v._v("\n第二次挥手：服务端收到 "),e("code",[v._v("FIN")]),v._v(" 码后，会发送 "),e("code",[v._v("ACK")]),v._v(" 码给客户端，表示服务端已经知道客户端传完了。"),e("br"),v._v("\n客户端收到 "),e("code",[v._v("ACK")]),v._v(" 码以后就会把数据传递给服务端的通道关闭；"),e("br"),v._v("\n第三次挥手：服务端把响应的数据发送完毕后，会发送 "),e("code",[v._v("FIN")]),v._v(" 码给客户端，表示服务端的响应数据已经发送完毕；"),e("br"),v._v("\n第四次挥手：客户端收到 "),e("code",[v._v("FIN")]),v._v(" 码后，会发送 "),e("code",[v._v("ACK")]),v._v(" 码数据包给服务端，表示客户端已经知道数据发送完毕；"),e("br"),v._v("\n服务端收到ACK码后，可以安心的把数据传递通道关闭掉。")])]),v._v(" "),e("h3",{attrs:{id:"为什么是四次挥手而不是三次？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么是四次挥手而不是三次？"}},[v._v("#")]),v._v(" 为什么是四次挥手而不是三次？")]),v._v(" "),e("p",[v._v("因为服务端在接收到 "),e("code",[v._v("FIN")]),v._v(" 码后, 往往不会立即返回 "),e("code",[v._v("FIN")]),v._v(" 码, 必须等到服务端所有报文都发送完毕了，才能发 "),e("code",[v._v("FIN")]),v._v(" 码，因此先发一个 "),e("code",[v._v("ACK")]),v._v(" 码表示已经收到客户端的 "),e("code",[v._v("FIN")]),v._v(" 码，延迟一段时间才发 "),e("code",[v._v("FIN")]),v._v(" 码。这就造成了四次挥手。")]),v._v(" "),e("h3",{attrs:{id:"如果是三次挥手会有什么问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果是三次挥手会有什么问题？"}},[v._v("#")]),v._v(" 如果是三次挥手会有什么问题？")]),v._v(" "),e("p",[v._v("等于说服务端将 "),e("code",[v._v("ACK")]),v._v(" 和 "),e("code",[v._v("FIN")]),v._v(" 的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为 "),e("code",[v._v("FIN")]),v._v(" 码没有到达服务端，从而让客户端不断的重发 "),e("code",[v._v("FIN")]),v._v(" 码。")]),v._v(" "),e("h3",{attrs:{id:"为何客户端最后还等待-2msl？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为何客户端最后还等待-2msl？"}},[v._v("#")]),v._v(" 为何客户端最后还等待 2MSL？")]),v._v(" "),e("ul",[e("li",[v._v("即 "),e("code",[v._v("TIME - WAIT")]),v._v(" 状态的作用是什么；")]),v._v(" "),e("li",[e("code",[v._v("MSL")]),v._v(" = 最长报文段寿命（"),e("code",[v._v("Maximum Segment Lifetime")]),v._v("）")])]),v._v(" "),e("p",[v._v("客户端需要保证最后一次发送的 "),e("code",[v._v("ACK")]),v._v(" 码到服务器，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启 "),e("code",[v._v("2MSL")]),v._v(" 计时")]),v._v(" "),e("h2",{attrs:{id:"从输入url到页面展示，发生了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到页面展示，发生了什么"}},[v._v("#")]),v._v(" 从输入URL到页面展示，发生了什么")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("过程")]),v._v(" "),e("ul",[e("li",[v._v("浏览器根据 "),e("code",[v._v("URL")]),v._v(" 进行 "),e("code",[v._v("DNS")]),v._v(" 查询")]),v._v(" "),e("li",[v._v("首先从 "),e("code",[v._v("DNS")]),v._v(" 缓存中查询")]),v._v(" "),e("li",[v._v("若没有在缓存中找到，则不停的向上一级请求 "),e("code",[v._v("DNS")]),v._v(" 服务器")]),v._v(" "),e("li",[v._v("获得 "),e("code",[v._v("IP")]),v._v(" 地址，建立 "),e("code",[v._v("TCP")]),v._v(" 连接")]),v._v(" "),e("li",[v._v("构造 "),e("code",[v._v("HTTP")]),v._v(" 请求报")]),v._v(" "),e("li",[v._v("添加一些 "),e("code",[v._v("HTTP")]),v._v(" 首部")]),v._v(" "),e("li",[v._v("根据同源策略添加 "),e("code",[v._v("cookie")])]),v._v(" "),e("li",[v._v("在 "),e("code",[v._v("TCP")]),v._v(" 连接上发送 "),e("code",[v._v("HTTP")]),v._v(" 请求报文，等待响应")]),v._v(" "),e("li",[v._v("服务器处理 "),e("code",[v._v("HTTP")]),v._v(" 请求报文，返回 "),e("code",[v._v("HTTP")]),v._v(" 响应报文")]),v._v(" "),e("li",[v._v("浏览器处理服务器返回的 "),e("code",[v._v("HTTP")]),v._v(" 响应报文，若为 "),e("code",[v._v("HTML")]),v._v(" 则渲染页面，不包括脚本的简单渲染流程如下:\n"),e("ul",[e("li",[e("ol",[e("li",[v._v("解析 "),e("code",[v._v("DOM")]),v._v("、"),e("code",[v._v("CSSOM")])])])]),v._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[v._v("根据 "),e("code",[v._v("DOM")]),v._v("、"),e("code",[v._v("CSSOM")]),v._v(" 计算渲染树")])])]),v._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[v._v("根据渲染树进行布局")])])]),v._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[v._v("重绘，至此，用户可以看到页面了")])])])])])])]),v._v(" "),e("p",[e("strong",[v._v("DNS解析(递归查找)")])]),v._v(" "),e("p",[v._v("DNS缓存 -> 本地域名服务器 -> 根域名服务器 -> 顶级域名服务器 -> 权限域名服务器"),e("br"),v._v("\nDNS缓存 <- 本地域名服务器 <- 根域名服务器 <- 顶级域名服务器 <- 权限域名服务器")]),v._v(" "),e("h2",{attrs:{id:"什么是-tcp-和-udp？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-tcp-和-udp？"}},[v._v("#")]),v._v(" 什么是 TCP 和 UDP？")]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[e("code",[v._v("TCP")]),v._v("（"),e("code",[v._v("Transmission Control Protocol")]),v._v("，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。"),e("br"),v._v(" "),e("code",[v._v("UDP")]),v._v(" （"),e("code",[v._v("User Datagram Protocol")]),v._v("，用户数据包协议），是一种面向无连接的、不可靠的、基于数据包的传输层通信协议，通过端口号把数据包分发给正确的程序")])]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[v._v("具体分析")]),v._v(" "),e("p",[v._v("具体来分析，和 "),e("code",[v._v("UDP")]),v._v(" 相比，"),e("code",[v._v("TCP")]),v._v(" 有三大核心特性:")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("面向连接")]),v._v(" 所谓的连接，指的是客户端和服务端的连接，在双方互相通信之前，"),e("code",[v._v("TCP")]),v._v(" 需要三次握手建立连接，而 "),e("code",[v._v("UDP")]),v._v(" 没有相应建立连接的过程。")]),v._v(" "),e("li",[e("code",[v._v("可靠性")]),v._v(" "),e("code",[v._v("TCP")]),v._v(" 花了非常多的功夫保证连接的可靠，这个可靠性体现在两个方面，一个是有状态，另一个是可控制。\n"),e("code",[v._v("TCP")]),v._v(" 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。\n当意识到丢包了或者网络环境不佳，"),e("code",[v._v("TCP")]),v._v(" 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。\n相应的，"),e("code",[v._v("UDP")]),v._v(" 就是无状态, 不可控的。")]),v._v(" "),e("li",[e("code",[v._v("基于字节流")]),v._v(" "),e("code",[v._v("UDP")]),v._v(" 的数据传输是基于数据包的，这是因为仅仅只是继承了 "),e("code",[v._v("IP")]),v._v(" 层的特性，而 "),e("code",[v._v("TCP")]),v._v(" 为了维护状态，将一个个 "),e("code",[v._v("IP")]),v._v(" 包变成了字节流。")])])]),v._v(" "),e("h2",{attrs:{id:"对于定长和不定长的数据，http-是怎么传输的？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对于定长和不定长的数据，http-是怎么传输的？"}},[v._v("#")]),v._v(" 对于定长和不定长的数据，HTTP 是怎么传输的？")]),v._v(" "),e("h3",{attrs:{id:"定长包体"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定长包体"}},[v._v("#")]),v._v(" 定长包体")]),v._v(" "),e("p",[v._v("对于定长包体而言，发送端在传输的时候一般会带上 "),e("code",[v._v("Content-Length")]),v._v(", 来指明包体的长度。")]),v._v(" "),e("p",[v._v("如果设置的 "),e("code",[v._v("Content-Length")]),v._v(" 大于实际的长度，则会无法显示，如果小于实际的长度，则浏览器会进行截断。")]),v._v(" "),e("h3",{attrs:{id:"不定长包体"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不定长包体"}},[v._v("#")]),v._v(" 不定长包体")]),v._v(" "),e("p",[v._v("可以设置另一个 "),e("code",[v._v("HTTP")]),v._v(" 头部字段 -> "),e("code",[v._v("Transfer-Encoding: chunked")])]),v._v(" "),e("p",[v._v("表示分块传输数据，设置这个字段后会自动产生两个效果:")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Content-Length")]),v._v(" 字段会被忽略")]),v._v(" "),e("li",[v._v("基于长连接持续推送动态内容")])]),v._v(" "),e("h2",{attrs:{id:"http-如何处理大文件的传输？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-如何处理大文件的传输？"}},[v._v("#")]),v._v(" HTTP 如何处理大文件的传输？")]),v._v(" "),e("h3",{attrs:{id:"如何支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何支持"}},[v._v("#")]),v._v(" 如何支持")]),v._v(" "),e("p",[v._v("当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头: Accept-Ranges: none , 用来告知客户端这边是支持范围请求的。")]),v._v(" "),e("h3",{attrs:{id:"range-字段拆解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#range-字段拆解"}},[v._v("#")]),v._v(" Range 字段拆解")]),v._v(" "),e("p",[v._v("而对于客户端而言，它需要指定请求哪一部分，通过Range这个请求头字段确定，格式为bytes=x-y。接下来就来讨论一下这个 Range 的书写格式:")]),v._v(" "),e("ul",[e("li",[v._v("0-499表示从开始到第 499 个字节。")]),v._v(" "),e("li",[v._v("500- 表示从第 500 字节到文件终点。")]),v._v(" "),e("li",[v._v("-100表示文件的最后100个字节。")])]),v._v(" "),e("p",[v._v("服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回416错误码，否则读取相应片段，返回206状态码。")]),v._v(" "),e("p",[v._v("同时，服务器需要添加Content-Range字段，这个字段的格式根据请求头中Range字段的不同而有所差异。")]),v._v(" "),e("p",[v._v("具体来说，请求单段数据和请求多段数据，响应头是不一样的。")]),v._v(" "),e("p",[v._v("举个例子:")]),v._v(" "),e("div",{staticClass:"language-json line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-json"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 单段数据")]),v._v("\nRange"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" bytes="),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("-9")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 多段数据")]),v._v("\nRange"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" bytes="),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("-9")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("30")]),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("-39")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br")])]),e("h3",{attrs:{id:"单段数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单段数据"}},[v._v("#")]),v._v(" 单段数据")]),v._v(" "),e("p",[v._v("对于单段数据的请求，返回的响应如下:")]),v._v(" "),e("div",{staticClass:"language-json line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-json"}},[e("code",[v._v("HTTP/"),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("1.1")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("206")]),v._v(" Partial Content\nContent-Length"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("10")]),v._v("\nAccept-Ranges"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" bytes\nContent-Range"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" bytes "),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("-9")]),v._v("/"),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("100")]),v._v("\n\ni am xxxxx\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br"),e("span",{staticClass:"line-number"},[v._v("5")]),e("br"),e("span",{staticClass:"line-number"},[v._v("6")]),e("br")])]),e("p",[v._v("值得注意的是Content-Range字段，0-9表示请求的返回，100表示资源的总大小，很好理解。")]),v._v(" "),e("h2",{attrs:{id:"什么是-https？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-https？"}},[v._v("#")]),v._v(" 什么是 HTTPS？")]),v._v(" "),e("p",[e("code",[v._v("HTTPS")]),v._v(" 并不是一个新的协议, 而是一个加强版的 "),e("code",[v._v("HTTP")]),v._v("。其原理是在 "),e("code",[v._v("HTTP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v(" 之间建立了一个中间层，当 "),e("code",[v._v("HTTP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v(" 通信时并不是像以前那样直接通信，而是直接经过了一个中间层进行加密，将加密后的数据传给 "),e("code",[v._v("TCP")]),v._v(" 响应的，"),e("code",[v._v("TCP")]),v._v(" 必须将数据解密，才能传给上面的 "),e("code",[v._v("HTTP")]),v._v("。这个中间层也叫安全层。安全层的核心就是对数据加解密。")]),v._v(" "),e("h2",{attrs:{id:"传统-rsa-加密算法？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传统-rsa-加密算法？"}},[v._v("#")]),v._v(" 传统 RSA 加密算法？")]),v._v(" "),e("p",[e("code",[v._v("HTTPS")]),v._v(" 并不是一个新的协议, 它在 "),e("code",[v._v("HTTP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v(" 的传输中建立了一个安全层，利用"),e("strong",[v._v("对称加密和非对称机密结合数字证书认证")]),v._v("的方式，让传输过程的安全性大大提高。")]),v._v(" "),e("h3",{attrs:{id:"对称加密和非对称加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称加密和非对称加密"}},[v._v("#")]),v._v(" 对称加密和非对称加密")]),v._v(" "),e("p",[v._v("对称加密是最简单的方式，指的是加密和解密用的是同样的"),e("strong",[v._v("密钥")]),v._v("。")]),v._v(" "),e("p",[v._v("而对于非对称加密，如果有 A、 B 两把密钥，如果用 A 加密过的数据只能用 B 解密，反之，如果用 B 加密过的数据只能用 A 解密。")]),v._v(" "),e("p",[e("strong",[v._v("加解密过程")])]),v._v(" "),e("p",[v._v("接着我们来谈谈浏览器和服务器进行协商加解密的过程。")]),v._v(" "),e("ul",[e("li",[v._v("首先，浏览器会给服务器发送一个随机数 "),e("code",[v._v("client_random")]),v._v(" 和加密方法列表。")]),v._v(" "),e("li",[v._v("服务器接收后给浏览器返回另一个随机数 "),e("code",[v._v("server_random")]),v._v(" 和加密方法。")]),v._v(" "),e("li",[v._v("现在，两者拥有三样相同的凭证: "),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("server_random")]),v._v(" 和加密方法。")]),v._v(" "),e("li",[v._v("接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号")])]),v._v(" "),e("p",[e("strong",[v._v("各自应用的效果")])]),v._v(" "),e("p",[v._v("如果用对称加密的方式，那么第三方可以在中间获取到 "),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("server_random")]),v._v(" 和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。")]),v._v(" "),e("p",[v._v("那能不能只用非对称加密呢？理论上是可以的，但实际上非对称加密需要的计算量非常大，对于稍微大一点的数据即使用最快的处理器也非常耗时。后面有机会给大家分享一下 "),e("code",[v._v("RSA")]),v._v(" 非对称加密算法的原理，大家就会有更加直观的认识，这里我们先不深究。")]),v._v(" "),e("h3",{attrs:{id:"对称加密和非对称加密的结合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称加密和非对称加密的结合"}},[v._v("#")]),v._v(" 对称加密和非对称加密的结合")]),v._v(" "),e("p",[e("strong",[v._v("整个流程:")])]),v._v(" "),e("ul",[e("li",[v._v("浏览器向服务器发送 "),e("code",[v._v("client_random")]),v._v(" 和加密方法列表。")]),v._v(" "),e("li",[v._v("服务器接收到，返回 "),e("code",[v._v("server_random")]),v._v("、加密方法以及公钥。")]),v._v(" "),e("li",[v._v("浏览器接收，接着生成另一个随机数 "),e("code",[v._v("pre_random")]),v._v(", 并且用公钥加密，传给服务器。(敲黑板！重点操作！)")]),v._v(" "),e("li",[v._v("服务器用私钥解密这个被加密后的 "),e("code",[v._v("pre_random")]),v._v("。")])]),v._v(" "),e("p",[v._v("现在浏览器和服务器有三样相同的凭证: "),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("server_random")]),v._v(" 和 "),e("code",[v._v("pre_random")]),v._v("。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。")]),v._v(" "),e("p",[v._v("然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。")]),v._v(" "),e("p",[v._v("这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而拿不到 "),e("code",[v._v("pre_random")]),v._v("，也就无法生成最终的密钥了。")]),v._v(" "),e("p",[v._v("回头比较一下和单纯的使用非对称加密, 这种方式做了什么改进呢？本质上是防止了私钥加密的数据外传。单独使用非对称加密，最大的漏洞在于服务器传数据给浏览器只能用私钥加密，这是危险产生的根源。利用对称和非对称加密结合的方式，就防止了这一点，从而保证了安全。")]),v._v(" "),e("h3",{attrs:{id:"添加数字证书"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加数字证书"}},[v._v("#")]),v._v(" 添加数字证书")]),v._v(" "),e("p",[v._v("尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 "),e("code",[v._v("DNS")]),v._v(" 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。")]),v._v(" "),e("p",[v._v("事实上 "),e("code",[v._v("HTTPS")]),v._v(" 在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。")]),v._v(" "),e("p",[e("strong",[v._v("传输过程")])]),v._v(" "),e("p",[v._v("为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫 "),e("code",[v._v("CA(Certificate Authority)")]),v._v(", 认证通过后 "),e("code",[v._v("CA")]),v._v(" 会给服务器颁发数字证书。")]),v._v(" "),e("p",[v._v("这个数字证书有两个作用:")]),v._v(" "),e("ul",[e("li",[v._v("服务器向浏览器证明自己的身份。")]),v._v(" "),e("li",[v._v("把公钥传给浏览器。")])]),v._v(" "),e("p",[v._v("这个验证的过程发生在什么时候呢？")]),v._v(" "),e("p",[v._v("当服务器传送 "),e("code",[v._v("server_random")]),v._v("、加密方法的时候，顺便会带上数字证书(包含了公钥), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。")]),v._v(" "),e("p",[v._v("现在我们来梳理一下 "),e("code",[v._v("HTTPS")]),v._v(" 最终的加解密过程:")]),v._v(" "),e("p",[e("img",{attrs:{src:t(266),alt:""}})]),v._v(" "),e("p",[e("strong",[v._v("认证过程")])]),v._v(" "),e("p",[v._v("浏览器拿到数字证书后，如何来对证书进行认证呢？")]),v._v(" "),e("p",[v._v("首先，会读取证书中的明文内容。"),e("code",[v._v("CA")]),v._v(" 进行数字证书的签名时会保存一个 "),e("code",[v._v("Hash")]),v._v(" 函数，用这个函数来计算明文内容得到信息 "),e("code",[v._v("A")]),v._v("，然后用公钥解密明文内容得到信息 "),e("code",[v._v("B")]),v._v("，两份信息做比对，一致则表示认证合法。")]),v._v(" "),e("p",[v._v("当然有时候对于浏览器而言，它不知道哪些 "),e("code",[v._v("CA")]),v._v(" 是值得信任的，因此会继续查找 "),e("code",[v._v("CA")]),v._v(" 的上级 "),e("code",[v._v("CA")]),v._v("，以同样的信息比对方式验证上级 "),e("code",[v._v("CA")]),v._v(" 的合法性。一般根级的 "),e("code",[v._v("CA")]),v._v(" 会内置在操作系统当中，当然如果向上找没有找到根级的 "),e("code",[v._v("CA")]),v._v("，那么将被视为不合法。")]),v._v(" "),e("h2",{attrs:{id:"tls1-2-握手的过程？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls1-2-握手的过程？"}},[v._v("#")]),v._v(" TLS1.2 握手的过程？")]),v._v(" "),e("p",[e("code",[v._v("HTTPS")]),v._v("，其实它并不是一个新的协议，而是在 "),e("code",[v._v("HTTP")]),v._v(" 下面增加了一层 "),e("code",[v._v("SSL/TLS")]),v._v(" 协议，简单的讲，"),e("code",[v._v("HTTPS = HTTP + SSL/TLS")]),v._v("。")]),v._v(" "),e("p",[e("code",[v._v("SSL")]),v._v(" 即安全套接层（"),e("code",[v._v("Secure Sockets Layer")]),v._v("），在 "),e("code",[v._v("OSI")]),v._v(" 七层模型中处于会话层(第 "),e("code",[v._v("5")]),v._v(" 层)。之前 "),e("code",[v._v("SSL")]),v._v(" 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 "),e("code",[v._v("TLS")]),v._v("（传输层安全，"),e("code",[v._v("Transport Layer Security")]),v._v("），并被当做 "),e("code",[v._v("TLS1.0")]),v._v(" 的版本，准确地说，"),e("code",[v._v("TLS1.0 = SSL3.1。")])]),v._v(" "),e("h3",{attrs:{id:"tls-1-2-握手过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-2-握手过程"}},[v._v("#")]),v._v(" TLS 1.2 握手过程")]),v._v(" "),e("p",[e("img",{attrs:{src:t(267),alt:""}})]),v._v(" "),e("p",[e("strong",[v._v("具体步骤如下：")]),v._v("\n<<<<<<< HEAD")]),v._v(" "),e("ul",[e("li",[v._v("首先，浏览器向服务器发送 "),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("TLS")]),v._v(" 版本、加密套件列表。\n=======")]),v._v(" "),e("li",[v._v("浏览器向服务器发送 "),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("TLS")]),v._v(" 版本、加密套件列表。")])]),v._v(" "),e("blockquote",[e("blockquote",[e("blockquote",[e("blockquote",[e("blockquote",[e("blockquote",[e("blockquote",[e("p",[v._v("51bcde1a0d1c1f2a72f5fc4e0add24420e0bf711")])])])])])])])]),v._v(" "),e("ul",[e("li",[v._v("服务器接收到，并返回 "),e("code",[v._v("server_random")]),v._v("、"),e("code",[v._v("server_params")]),v._v("、确认 TLS 版本、加密套件列表、数字证书。")]),v._v(" "),e("li",[v._v("客户端验证服务端传来的证书和签名是否通过，如果验证通过，则传递 "),e("code",[v._v("client_params")]),v._v(" 这个参数给服务器，并通过 "),e("code",[v._v("ECDHE")]),v._v(" 算法计算出 "),e("code",[v._v("pre_random")]),v._v(", 最后将 "),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("server_random")]),v._v(" 和 "),e("code",[v._v("pre_random")]),v._v(" 这三个参数通过一个伪随机数函数来计算出最终的 "),e("code",[v._v("secret")]),v._v("。")]),v._v(" "),e("li",[v._v("服务端开始用 "),e("code",[v._v("ECDHE")]),v._v(" 算法生成 "),e("code",[v._v("pre_random")]),v._v("，接着用和客户端同样的伪随机数函数生成最后的 "),e("code",[v._v("secret")]),v._v("。")])]),v._v(" "),e("p",[e("strong",[v._v("数字证书认证过程？")])]),v._v(" "),e("p",[e("strong",[v._v("哈希摘要算法")]),v._v("，将服务端的证书信息通过这个算法生成一个摘要(可以理解为比较短的字符串)，用来标识这个服务端的身份，用"),e("strong",[v._v("私钥加密")]),v._v("后把加密后的标识和自己的公钥传给客户端。客户端拿到这个"),e("strong",[v._v("公钥来解密")]),v._v("，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务端的身份。这也就是所谓数字签名的原理。其中除了哈希算法，最重要的过程是"),e("strong",[v._v("私钥加密，公钥解密")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"tls1-3-握手的过程？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls1-3-握手的过程？"}},[v._v("#")]),v._v(" TLS1.3 握手的过程？")]),v._v(" "),e("p",[e("strong",[v._v("握手改进")])]),v._v(" "),e("p",[e("img",{attrs:{src:t(268),alt:""}})]),v._v(" "),e("p",[v._v("大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到client_params，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算secret，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。")]),v._v(" "),e("p",[v._v("这种 TLS 1.3 握手方式也被叫做1-RTT握手。但其实这种1-RTT的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。")]),v._v(" "),e("p",[e("strong",[v._v("具体步骤如下：")])]),v._v(" "),e("ul",[e("li",[v._v("首先，浏览器向服务器发送 "),e("code",[v._v("client_params")]),v._v("、"),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("TLS")]),v._v(" 版本、加密套件列表。")]),v._v(" "),e("li",[v._v("服务器接收到，并返回 "),e("code",[v._v("server_random")]),v._v("、"),e("code",[v._v("server_params")]),v._v("、确认 TLS 版本、加密套件列表、服务器使用的证书，并服务端开始用 "),e("code",[v._v("ECDHE")]),v._v(" 算法生成 "),e("code",[v._v("pre_random")]),v._v("，并通过这三个参数通过一个伪随机数函数来计算出最终的 "),e("code",[v._v("secret")]),v._v("。")]),v._v(" "),e("li",[v._v("客户端验证服务端传来的证书和签名是否通过，如果验证通过，则通过 "),e("code",[v._v("ECDHE")]),v._v(" 算法计算出 "),e("code",[v._v("pre_random")]),v._v(", 最后将 "),e("code",[v._v("client_random")]),v._v("、"),e("code",[v._v("server_random")]),v._v(" 和 "),e("code",[v._v("pre_random")]),v._v(" 这三个参数通过一个伪随机数函数来计算出最终的 "),e("code",[v._v("secret")]),v._v("。")])]),v._v(" "),e("p",[e("code",[v._v("TLS1.3")]),v._v(" 在 "),e("code",[v._v("TLS1.2")]),v._v(" 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 "),e("code",[v._v("PSK")]),v._v(" 做到了 "),e("code",[v._v("0-RTT")]),v._v(" 连接。")]),v._v(" "),e("h2",{attrs:{id:"xss-讲一下？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#xss-讲一下？"}},[v._v("#")]),v._v(" XSS 讲一下？")]),v._v(" "),e("p",[e("code",[v._v("XSS")]),v._v(" 攻击, 全称是 "),e("code",[v._v("Cross Site Scripting")]),v._v("(即跨站脚本攻击), 是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括:")]),v._v(" "),e("ul",[e("li",[v._v("一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。")]),v._v(" "),e("li",[v._v("两个利用: 利用 "),e("code",[v._v("CSP")]),v._v("，利用 "),e("code",[v._v("Cookie")]),v._v(" 的 "),e("code",[v._v("HttpOnly")]),v._v(" 属性。")])]),v._v(" "),e("h2",{attrs:{id:"csrf-攻击讲一下？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#csrf-攻击讲一下？"}},[v._v("#")]),v._v(" CSRF 攻击讲一下？")]),v._v(" "),e("p",[e("code",[v._v("CSRF(Cross-site request forgery)")]),v._v(", 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。")]),v._v(" "),e("p",[e("code",[v._v("CSRF")]),v._v(" 攻击一般会有三种方式:")]),v._v(" "),e("ul",[e("li",[v._v("自动 "),e("code",[v._v("GET")]),v._v(" 请求")]),v._v(" "),e("li",[v._v("自动 "),e("code",[v._v("POST")]),v._v(" 请求")]),v._v(" "),e("li",[v._v("诱导点击发送 "),e("code",[v._v("GET")]),v._v(" 请求。")])]),v._v(" "),e("p",[v._v("防范措施: 利用 "),e("code",[v._v("Cookie")]),v._v(" 的 "),e("code",[v._v("SameSite")]),v._v(" 属性、验证来源站点和 "),e("code",[v._v("CSRF Token")]),v._v("。")])])}],a=(t(269),t(0)),c=Object(a.a)({},(function(){var v=this.$createElement;this._self._c;return this._m(0)}),e,!1,null,null,null);_.default=c.exports}}]);